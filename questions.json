{
  "certifications": [
    {
      "id": "jsdev1",
      "name": "JavaScript Developer I",
      "passingScore": 70,
      "categories": [
        {
          "name": "Variables, Types, and Collections",
          "description": "The topic will test how effectively JavaScript programmers can handle variable creation, initialization, type coercion, and data manipulation. You will need to demonstrate knowledge of strings, numbers, dates, arrays, and JSON handling. The Javascript Developer I exam will require a deep understanding of these concepts and their proper application in real-world scenarios."
        },
        {
          "name": "Objects, Functions, and Classes",
          "description": "In this section, the focus is on applying object-oriented principles, functions, and classes. As a Salesforce JavaScript programmer, you will need to locate optimal function implementations and understand how to structure objects and classes for business solutions. You will also be tested on your ability to use JavaScript modules and decorators, while analyzing variable scope and execution flow."
        },
        {
          "name": "Browser and Events",
          "description": "The topic will challenge your ability to work with events, event handlers, and the DOM. You will need to demonstrate how to manage event propagation and utilize browser-specific APIs. Additionally, proficiency in using browser developer tools to investigate code behavior will be tested, making it crucial for you to understand browser interactions thoroughly."
        },
        {
          "name": "Debugging and Error Handling",
          "description": "This section will measure the ability of JavaScript programmer to properly handle errors and debug JavaScript code. You will be expected to apply debugging techniques, such as using the console and breakpoints, to resolve issues. Proper error handling is crucial, and the exam will evaluate your skills in managing and correcting errors efficiently within your code."
        },
        {
          "name": "Asynchronous Programming",
          "description": "Asynchronous programming is a key concept in JavaScript, and this section tests your understanding of event loops, asynchronous code execution, and handling promises. Salesforce JavaScript programmer will need to demonstrate their ability to implement asynchronous solutions for business requirements."
        },
        {
          "name": "Server Side JavaScript",
          "description": "This section focuses on Node.js and server-side JavaScript. Salesforce JavaScript programmers will be tested on their ability to identify appropriate Node.js implementations and commands for given scenarios. Additionally, you will need to recognize which Node.js core modules, libraries, and package management solutions fit specific requirements, reflecting your understanding of server-side development with JavaScript."
        },
        {
          "name": "Testing",
          "description": "In the topic, you will be required to evaluate unit tests and improve them. The exam will assess your ability to identify ineffective tests and modify them to make them more robust and accurate. This topic ensures that you can write and maintain effective tests, a crucial skill for ensuring code quality and reliability in professional environments."
        }
      ],
      "questions": [
        {
          "id": "q1",
          "text": "Which statement accurately describes an aspect of promises?",
          "options": [
            {
              "id": "o1",
              "text": ".then() manipulates and returns the original promise."
            },
            {
              "id": "o2",
              "text": "Arguments for the callback function passed to .then() are optional."
            },
            {
              "id": "o3",
              "text": ".then() cannot be added after a catch."
            },
            {
              "id": "o4",
              "text": "In a.then() function, returning results is not necessary since callbacks will catch the result of a previous promise."
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The correct answer is that arguments for the callback function passed to .then() are optional - you can call .then() without any arguments to simply pass the result forward. The incorrect options are: .then() returns a NEW promise (not the original), .then() CAN be chained after .catch() for error recovery, and returning results from .then() IS necessary to pass values down the promise chain.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q2",
          "text": "Refer to the following array:\n\nlet arr1 = [1, 2, 3, 4, 5];\nlet arr2 = arr1.slice(0, 5);\nconsole.log(arr2);\n▶ (5) [1, 2, 3, 4, 5]\n\nlet arr1 = [1, 2, 3, 4, 5];\nlet arr2 = Array.from(arr1);\nconsole.log(arr2);\n▶ (5) [1, 2, 3, 4, 5]\n\nWhich two lines of code result in a second array, arr2, being created such that arr2 is NOT a reference to arr1?",
          "options": [
            {
              "id": "o1",
              "text": "A. Let arr2 = arr1.sort();"
            },
            {
              "id": "o2",
              "text": "B. Let arr2 = arr1;"
            },
            {
              "id": "o3",
              "text": "C. Let arr2 = Array.from(arr1);"
            },
            {
              "id": "o4",
              "text": "D. Let arr2 = arr1.slice(0, 5);"
            }
          ],
          "correct": [
            "o3",
            "o4"
          ],
          "explanation": "Array.from() and slice() both create NEW arrays that are independent copies, not references. The incorrect options are: arr1.sort() sorts the original array IN-PLACE and returns a reference to it (not a new array), and arr1 assignment simply creates another reference to the same array. Modifying either reference would affect the original array.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q3",
          "text": "Considering type coercion, what does the following expression evaluate to? True + '13' + NaN",
          "options": [
            {
              "id": "o1",
              "text": "'true13NaN'"
            },
            {
              "id": "o2",
              "text": "'113NaN'"
            },
            {
              "id": "o3",
              "text": "'true13'"
            },
            {
              "id": "o4",
              "text": "14"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The result is 'true13NaN'. When the boolean true is added to a string '13', JavaScript coerces true to the string 'true' and concatenates them ('true' + '13' = 'true13'). Then NaN is also converted to the string 'NaN' and concatenated, resulting in 'true13NaN'. The presence of strings triggers string concatenation rather than numeric addition.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q4",
          "text": "A developer writes the code below to calculate the factorial of a given number: function sum(number){ return number * sum(number-1); } sum(3); What is the result of executing the code?",
          "options": [
            {
              "id": "o1",
              "text": "0"
            },
            {
              "id": "o2",
              "text": "6"
            },
            {
              "id": "o3",
              "text": "-Infinity"
            },
            {
              "id": "o4",
              "text": "Error"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The result is an Error (Maximum call stack size exceeded). This recursive function lacks a base case to stop recursion, so it will call itself infinitely: sum(3) calls sum(2), which calls sum(1), sum(0), sum(-1), etc. Eventually, the call stack runs out of memory and throws a stack overflow error. A correct factorial function needs a base case like 'if (number <= 1) return 1;' to terminate recursion.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q5",
          "text": "Which three browser specific APIs are available for developers to persist data between page loads? Choose 3 answers",
          "options": [
            {
              "id": "o1",
              "text": "Cookies"
            },
            {
              "id": "o2",
              "text": "localStorage"
            },
            {
              "id": "o3",
              "text": "indexedDB"
            },
            {
              "id": "o4",
              "text": "IIFEs"
            },
            {
              "id": "o5",
              "text": "Global variables"
            }
          ],
          "correct": [
            "o1",
            "o2",
            "o3"
          ],
          "explanation": "The three browser APIs that persist data across page loads are: Cookies (stored as HTTP headers and accessible via document.cookie), localStorage (key-value storage with no expiration), and indexedDB (low-level API for storing large amounts of structured data). The incorrect options are: IIFEs (Immediately Invoked Function Expressions) are just a JavaScript pattern for creating scope and don't store data, and global variables only exist in memory during the current page session - they're lost when the page reloads.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q6",
          "text": "Refer to code below: console.log(0); setTimeout(() => { console.log(1); }); console.log(2); setTimeout(() => { console.log(3); }, 0); console.log(4); In which sequence will the numbers be logged?",
          "options": [
            {
              "id": "o1",
              "text": "01234"
            },
            {
              "id": "o2",
              "text": "02413"
            },
            {
              "id": "o3",
              "text": "02431"
            },
            {
              "id": "o4",
              "text": "13024"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The sequence is 02413. JavaScript executes synchronous code first: console.log(0), console.log(2), and console.log(4) run immediately in order. The setTimeout callbacks are placed in the task queue and execute AFTER all synchronous code completes. Even though the second setTimeout has a delay of 0ms, it still must wait for the current execution context to finish. Once the call stack is empty, the callbacks execute in the order they were queued: first setTimeout logs 1, then second setTimeout logs 3.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q7",
          "text": "Which code statement correctly persists an object in localStorage?",
          "options": [
            {
              "id": "o1",
              "text": "const setLocalStorage = (storageKey, jsObject) => { window.localStorage.persist(storageKey, jsObject); }"
            },
            {
              "id": "o2",
              "text": "const setLocalStorage = (jsObject) => { window.localStorage.setItem(jsObject); }"
            },
            {
              "id": "o3",
              "text": "const setLocalStorage = (storageKey, jsObject) => { window.localStorage.setItem(storageKey, JSON.stringify(jsObject)); }"
            },
            {
              "id": "o4",
              "text": "const setLocalStorage = (jsObject) => { window.localStorage.connectObject(jsObject)); }"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "The correct approach is window.localStorage.setItem(storageKey, JSON.stringify(jsObject)). localStorage stores data as strings, so objects must be converted using JSON.stringify(). The method requires TWO parameters: a key (string) to identify the stored item, and the value to store. The incorrect options either: use non-existent methods like persist() or connectObject(), only provide one parameter when two are required, or fail to stringify the object which would store '[object Object]' instead of the actual data.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q8",
          "text": "A developer at Universal Containers is creating their new landing page. A script named personalizeWebsiteContent needs to be executed when the webpage is fully loaded (HTML content and all related files). Which implementation should be used?",
          "options": [
            {
              "id": "o1",
              "text": "Add a handler to the personalizeWebsiteContent script to handle the load event"
            },
            {
              "id": "o2",
              "text": "Add a handler to the personalizeWebsiteContent script to handle the DOMContentLoaded event"
            },
            {
              "id": "o3",
              "text": "Add a listener to the window object to handle the DOMContentLoaded event"
            },
            {
              "id": "o4",
              "text": "Add a listener to the window object to handle the load event"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Add a listener to the window object to handle the load event. The 'load' event fires AFTER the HTML content AND all related files (images, stylesheets, scripts) have finished loading, which matches the requirement. The DOMContentLoaded event fires earlier - when just the HTML is parsed but before external resources finish loading, so it doesn't meet the 'fully loaded' requirement. The handler should be attached to the window object (not the script itself) and listen for the 'load' event specifically.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q9",
          "text": "Refer to the code below: const pi = 3.1415326; What is the data type of pi?",
          "options": [
            {
              "id": "o1",
              "text": "Double"
            },
            {
              "id": "o2",
              "text": "Number"
            },
            {
              "id": "o3",
              "text": "Float"
            },
            {
              "id": "o4",
              "text": "Decimal"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The data type is Number. Unlike languages like Java or C++ that have separate types for integers, floats, doubles, and decimals, JavaScript has only ONE numeric type called 'Number'. This type represents all numeric values - both integers (like 42) and floating-point numbers (like 3.1415326) - using 64-bit double-precision IEEE 754 format. The other option names (Double, Float, Decimal) are not valid JavaScript data types.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q10",
          "text": "Teams at Universal Containers work on multiple JavaScript projects. UC is thinking about reusability. Going open-source or public is not an option. Which option is available to UC with npm?",
          "options": [
            {
              "id": "o1",
              "text": "Private packages are not supported, but they can use another package manager like yarn."
            },
            {
              "id": "o2",
              "text": "Private packages can be scoped, and scopes can be associated to a private registries."
            },
            {
              "id": "o3",
              "text": "Private registries are not supported by npm, but packages can be installed via git."
            },
            {
              "id": "o4",
              "text": "Private registries are not supported by npm, but packages can be installed via URL."
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Private packages CAN be scoped, and scopes can be associated with private registries. npm supports enterprise and private package management through scoped packages (like @mycompany/package-name) that can point to private npm registries. The incorrect options falsely claim that private packages or private registries aren't supported by npm. While packages can be installed via git or URL, npm DOES have native support for private registries through scoped packages, making this the recommended enterprise solution.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q11",
          "text": "Refer to the code below: Function changeValue(obj) { obj.value = obj.value/2; } const objA = {value: 10}; const objB = objA; changeValue(objB); const result = objA.value; What is the value of result after the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "Undefined"
            },
            {
              "id": "o2",
              "text": "NaN"
            },
            {
              "id": "o3",
              "text": "10"
            },
            {
              "id": "o4",
              "text": "5"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The result is 5. In JavaScript, objects are passed by reference, not by value. When objB is assigned to objA (objB = objA), both variables point to the SAME object in memory - not two separate copies. Therefore, when changeValue(objB) modifies obj.value, it's actually modifying the same object that objA references. The value is divided by 2 (10/2 = 5), and since both variables reference the same object, objA.value also equals 5. This demonstrates the difference between primitive values (passed by value) and objects (passed by reference).",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q12",
          "text": "A developer has a web server running with Node.js. The command to start the web server is node server.js. Which command can the developer run to debug what the module is doing during latency issues?",
          "options": [
            {
              "id": "o1",
              "text": "DEBUG=http,https node server.js"
            },
            {
              "id": "o2",
              "text": "DEBUG=true node server.js"
            },
            {
              "id": "o3",
              "text": "NODE_DEBUG=http,https node server.js"
            },
            {
              "id": "o4",
              "text": "NODE_DEBUG=true node server.js"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Use NODE_DEBUG=http,https node server.js to debug Node.js core modules. The NODE_DEBUG environment variable is specifically designed to enable debug output for Node.js built-in modules like 'http' and 'https'. You specify module names as a comma-separated list. The incorrect options either use 'DEBUG' (which is for third-party debug packages, not Node.js core), or use 'true' as a value (which doesn't specify which modules to debug). NODE_DEBUG with specific module names provides detailed debugging information about those modules' internal operations.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q13",
          "text": "A developer wants to use a module called DataPrettyPrint that exports one default function called printDate(). How can a developer import and use the printDate() function?",
          "options": [
            {
              "id": "o1",
              "text": "import DatePrettyPrint from './path/DatePrettyPrint.js'; DatePrettyPrint.printDate();"
            },
            {
              "id": "o2",
              "text": "import printDate from './path/DatePrettyPrint.js'; printDate();"
            },
            {
              "id": "o3",
              "text": "import printDate from './path/DatePrettyPrint.js'; DatePrettyPrint.printDate();"
            },
            {
              "id": "o4",
              "text": "import DatePrettyPrint() from './path/DatePrettyPrint.js'; printDate();"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Import it as: import printDate from './path/DatePrettyPrint.js'; then call printDate(). When a module has a DEFAULT export, you can import it with any name you choose (not necessarily the original function name). Since printDate is exported as the default function, you import it directly and call it immediately. The incorrect options either: try to access it as a property of an imported object (printDate is the function itself, not a property), import the module with one name but try to call a different name, or use invalid import syntax with parentheses.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q14",
          "text": "Which two options are core Node.js modules? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "iostream"
            },
            {
              "id": "o2",
              "text": "worker"
            },
            {
              "id": "o3",
              "text": "http"
            },
            {
              "id": "o4",
              "text": "exception"
            }
          ],
          "correct": [
            "o1",
            "o3"
          ],
          "explanation": "The core Node.js modules are 'iostream' and 'http'. Node.js includes built-in modules that don't require installation - 'http' is used for creating web servers and handling HTTP requests/responses, and 'iostream' handles input/output streams. The incorrect options 'worker' and 'exception' are not core Node.js module names. Note: While 'worker_threads' IS a core module, 'worker' alone is not. The 'exception' is not a module - errors are handled through try/catch blocks and error objects.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q15",
          "text": "Given HTML: <div><div id='row-uc'>Universal Container</div></div>. Which statement adds the 'priority-account' CSS class to the Universal Containers row?",
          "options": [
            {
              "id": "o1",
              "text": "document.querySelector('#row-uc').classes.push('priority-account');"
            },
            {
              "id": "o2",
              "text": "document.querySelector('#row-uc').classList.add('priority-account');"
            },
            {
              "id": "o3",
              "text": "document.querySelectorAll('#row-uc').classList.add('priority-account');"
            },
            {
              "id": "o4",
              "text": "document.getElementById('row-uc').addClass('priority-account');"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Use document.querySelector('#row-uc').classList.add('priority-account'). The classList property provides methods to manipulate CSS classes, and add() is the correct method to add a new class. The incorrect options either: try to use a non-existent 'classes' property with push() (classes is not an array), use querySelectorAll() which returns a NodeList (not a single element, so classList wouldn't work directly), or use a non-existent addClass() method (that's jQuery syntax, not vanilla JavaScript). querySelector() selects a single element by ID, and classList.add() properly adds the class.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q16",
          "text": "Refer to the code below: let inArray = [[1,2],[3,4,5]]; Which two statements result in the array [1,2,3,4,5]? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "[].concat(...inArray);"
            },
            {
              "id": "o2",
              "text": "[].concat.apply([],inArray);"
            },
            {
              "id": "o3",
              "text": "[].concat.apply(inArray,[]);"
            },
            {
              "id": "o4",
              "text": "[].concat([...inArray]);"
            }
          ],
          "correct": [
            "o1",
            "o2"
          ],
          "explanation": "Both [].concat(...inArray) and [].concat.apply([],inArray) correctly flatten the array. The spread operator (...inArray) unpacks the nested arrays as individual arguments to concat(), merging them into one array. The apply() method does the same thing by passing the nested arrays as arguments. The incorrect options either: have the apply() arguments reversed (should be apply(thisArg, argsArray)), or wrap the spread in another array ([...inArray]) which creates [[1,2],[3,4,5]] instead of flattening. Both correct options take [[1,2],[3,4,5]] and produce [1,2,3,4,5].",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q17",
          "text": "A developer creates an input to upload files and display image preview. In lines 04 and 08, which code allows the user to select an image from their local computer and display it in the browser?",
          "options": [
            {
              "id": "o1",
              "text": "04: const reader = new FileReader(); 08: if (file) reader.readAsDataURL(file);"
            },
            {
              "id": "o2",
              "text": "04: const reader = new File(); 08: if (file) URL.createObjectURL(file);"
            },
            {
              "id": "o3",
              "text": "04: const reader = new FileReader(); 08: if (file) URL.createObjectURL(file);"
            },
            {
              "id": "o4",
              "text": "04: const reader = new File(); 08: if (file) reader.readAsDataURL(file);"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Use: const reader = new FileReader(); and then reader.readAsDataURL(file). The FileReader API is designed to read file contents from the user's computer. The readAsDataURL() method converts the file into a base64-encoded data URL that can be directly assigned to an img element's src attribute for preview. The incorrect options either: use non-existent 'File' constructor (File objects come from input elements, not a constructor), use URL.createObjectURL() which requires different setup (creates a blob URL, not a data URL), or combine wrong APIs together. FileReader with readAsDataURL is the standard approach for reading and previewing local files.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q18",
          "text": "A developer at Universal Containers creates a new landing page. Which statement should be used to call personalizeWebsiteContent when the webpage is fully loaded?",
          "options": [
            {
              "id": "o1",
              "text": "document.addEventListener('onDOMContextLoaded', personalizeWebsiteContext);"
            },
            {
              "id": "o2",
              "text": "document.addEventListener('DOMContextLoaded', personalizeWebsiteContext);"
            },
            {
              "id": "o3",
              "text": "window.addEventListener('load', personalizeWebsiteContext);"
            },
            {
              "id": "o4",
              "text": "window.addEventListener('onload', personalizeWebsiteContext);"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Use window.addEventListener('load', personalizeWebsiteContext). The 'load' event fires when the entire page is fully loaded, including all dependent resources like stylesheets and images. The event listener should be attached to the window object (not document). The incorrect options either: use non-existent event names like 'onDOMContextLoaded' or 'DOMContextLoaded' (the correct event for early DOM loading is 'DOMContentLoaded', but it fires BEFORE resources load), or use 'onload' as the event name (incorrect - in addEventListener, use 'load' without the 'on' prefix; 'onload' is only used for inline HTML attributes like <body onload=\"\">).",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q19",
          "text": "Refer to the following code that imports a module named utils:\n\nimport {foo, bar} from '/path/Utils.js';\nfoo();\nbar();\n\nWhich two implementations of Utils.js export foo and bar such that the code above runs without error? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "A. const foo = () => { return 'foo'; } const bar = () => { return 'bar'; } export { bar, foo }"
            },
            {
              "id": "o2",
              "text": "B. // FooUtils.js and BarUtils.js exist Import {foo} from '/path/FooUtils.js'; Import {bar} from '/path/BarUtils.js';"
            },
            {
              "id": "o3",
              "text": "C. export default class { foo() { return 'foo'; } bar() { return 'bar'; } }"
            },
            {
              "id": "o4",
              "text": "D. const foo = () => { return 'foo';} const bar = () => {return 'bar'; } Export default foo, bar;"
            }
          ],
          "correct": [
            "o1",
            "o3"
          ],
          "explanation": "Both 'export { bar, foo }' (named exports) and 'export default class' with methods work. For import {foo, bar}, you need NAMED exports, which can be done by exporting variables/functions explicitly: export { bar, foo }. Alternatively, a default exported class with foo() and bar() methods also works (though you'd access them differently). The incorrect options either: re-import from other files (doesn't answer how Utils.js itself should export), or use invalid syntax 'Export default foo, bar' (you can only have ONE default export, and the syntax is wrong - default exports don't use commas for multiple items).",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q20",
          "text": "Given the code below:\n\nconst delay = async delay => {\n  return new Promise((resolve, reject) => {\n    console.log(1);\n    setTimeout(resolve, delay);\n  });\n};\n\nconst callDelay = async () => {\n  console.log(2);\n  const yup = await delay(1000);\n  console.log(3);\n}\n\nconsole.log(4);\ncallDelay();\nconsole.log(5);\n\nWhat is logged to the console?",
          "options": [
            {
              "id": "o1",
              "text": "4 2 1 5 3"
            },
            {
              "id": "o2",
              "text": "2 1 3 4 5"
            },
            {
              "id": "o3",
              "text": "4 5 2 1 3"
            },
            {
              "id": "o4",
              "text": "1 2 3 4 5"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The sequence is 4 2 1 5 3. Execution flows as follows: 1) console.log(4) runs immediately (synchronous). 2) callDelay() is invoked - the function starts executing but is async. 3) console.log(2) runs (synchronous inside async function). 4) delay(1000) is called, which immediately logs 1 (before the setTimeout), then returns a Promise. 5) await pauses callDelay()'s execution, releasing control back to the main thread. 6) console.log(5) runs (synchronous). 7) After 1000ms, the promise resolves, callDelay() resumes, and console.log(3) runs. Key point: code inside an async function runs synchronously UNTIL it hits await.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q21",
          "text": "Refer to the code below:\n\nx = 3.14;\nfunction myFunction() {\n  'use strict';\n  y = x;\n}\nz = x;\nmyFunction();\n\nWhat is the result?",
          "options": [
            {
              "id": "o1",
              "text": "z is equal to 3.14, use strict has effect only on line 5, Line 5 throws an error"
            },
            {
              "id": "o2",
              "text": "z is undefined, y is 3.14, no errors"
            },
            {
              "id": "o3",
              "text": "Both y and z are 3.14, no errors"
            },
            {
              "id": "o4",
              "text": "All variables throw errors due to strict mode"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The result is: z equals 3.14, AND line 5 throws a ReferenceError. Outside the function, x = 3.14 creates a global variable (sloppy mode allows this). Then z = x successfully assigns 3.14 to global z (also in sloppy mode). However, inside myFunction(), 'use strict' is enabled, which prohibits creating variables without declaration keywords (let, const, var). When y = x executes, JavaScript tries to create an undeclared variable y, but strict mode throws a ReferenceError: 'y is not defined'. Important: 'use strict' only affects the function scope it's declared in, not the outer code. Variables x and z are created successfully in sloppy mode before the error occurs.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q22",
          "text": "In the browser, the window object is often used to assign variables that require the broadest scope in an application. Node.js application does not have access to the window object by default. Which two methods are used to address this? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "Assign variables to the global object."
            },
            {
              "id": "o2",
              "text": "Create a new window object in the root file."
            },
            {
              "id": "o3",
              "text": "Use the document object instead of the window object."
            },
            {
              "id": "o4",
              "text": "Assign variables to module.exports and require them as needed."
            }
          ],
          "correct": [
            "o1",
            "o4"
          ],
          "explanation": "The two correct approaches are: 1) Assign variables to the global object (Node.js equivalent of window - accessed via 'global.myVar = value'), and 2) Assign variables to module.exports and require them as needed (the Node.js module pattern for sharing data between files). The incorrect options: Creating a new window object doesn't help because Node.js APIs don't recognize it, and the document object doesn't exist in Node.js (it's browser-specific for DOM manipulation). The module.exports approach is actually preferred over global variables because it provides better encapsulation and avoids namespace pollution.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q23",
          "text": "Refer to the code below:\n\nlet timedFunction = () => {\n  console.log('Timer called.');\n};\nlet timerId = setTimeout(timedFunction, 1000);\n\nWhich statement allows a developer to cancel the scheduled timed function?",
          "options": [
            {
              "id": "o1",
              "text": "removeTimeout(timerId);"
            },
            {
              "id": "o2",
              "text": "clearTimeout(timedFunction);"
            },
            {
              "id": "o3",
              "text": "removeTimeout(timedFunction);"
            },
            {
              "id": "o4",
              "text": "clearTimeout(timerId);"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Use clearTimeout(timerId) to cancel a scheduled timeout. The setTimeout() function returns a unique timer ID (a number), which you must save and pass to clearTimeout() to cancel that specific timeout. The incorrect options either: use a non-existent 'removeTimeout()' function (the correct function is clearTimeout), or pass the function reference instead of the timer ID (clearTimeout needs the ID, not the function itself). Only the timer ID uniquely identifies which scheduled timeout to cancel, especially when multiple timeouts exist.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q24",
          "text": "A developer is setting up a new Node.js server with a client library that is built using events and callbacks. The library will establish a web socket connection and handle receipt of messages. Which code segment shows the correct way to set up a client with two events that listen at execution time?",
          "options": [
            {
              "id": "o1",
              "text": "ws.on('connect', () => { console.log('connected to client'); }); ws.on('error', (error) => { console.log('ERROR', error); });"
            },
            {
              "id": "o2",
              "text": "try{ ws.connect(() => { console.log('connected to client'); }); } catch(error) { console.log('ERROR',error); }"
            },
            {
              "id": "o3",
              "text": "ws.on('connect', () => { console.log('connected to client'); ws.on('error', (error) => { console.log('ERROR', error); }); });"
            },
            {
              "id": "o4",
              "text": "ws.connect(() => { console.log('connected to client'); }).catch((error) => { console.log('ERROR', error); });"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Use ws.on('connect', callback) and ws.on('error', callback) registered at the same level. Event-driven Node.js libraries (like WebSocket clients) use the .on() method to register event listeners. Both events should be registered BEFORE the connection is established so they're ready when the events fire. The incorrect options either: use try/catch (which doesn't work for asynchronous events - it only catches synchronous errors), nest the error handler inside the connect handler (error events can fire before connection, so this might miss errors), or use promise-style .catch() syntax (this library uses events, not promises). Event listeners with .on() are the standard pattern for Node.js event-based libraries.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q25",
          "text": "Given a value, which three options can a developer use to detect if the value is NaN? Choose 3 answers",
          "options": [
            {
              "id": "o1",
              "text": "value == NaN"
            },
            {
              "id": "o2",
              "text": "Number.isNaN(value)"
            },
            {
              "id": "o3",
              "text": "value === Number.NaN"
            },
            {
              "id": "o4",
              "text": "Object.is(value, NaN)"
            },
            {
              "id": "o5",
              "text": "value !== value"
            }
          ],
          "correct": [
            "o2",
            "o4",
            "o5"
          ],
          "explanation": "The three ways to detect NaN are: Number.isNaN(value) - the most reliable and recommended method that specifically checks if the value is NaN; Object.is(value, NaN) - uses JavaScript's SameValue algorithm which correctly identifies NaN; and value !== value - works because NaN is the ONLY value in JavaScript that is not equal to itself. The incorrect options (value == NaN and value === Number.NaN) fail because NaN never equals anything, including itself (NaN == NaN is false). This quirky behavior is why special methods like Number.isNaN() are necessary. Note: Avoid the global isNaN() function as it coerces values first, leading to unexpected results.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q26",
          "text": "Refer to the code declarations below:\n\nlet str1 = 'Java';\nlet str2 = 'Script';\n\nWhich three expressions return the string 'JavaScript'? Choose 3 answers",
          "options": [
            {
              "id": "o1",
              "text": "str1.concat(str2);"
            },
            {
              "id": "o2",
              "text": "str1.join(str2);"
            },
            {
              "id": "o3",
              "text": "str1 + str2;"
            },
            {
              "id": "o4",
              "text": "`${str1}${str2}`;"
            },
            {
              "id": "o5",
              "text": "concat(str1, str2);"
            }
          ],
          "correct": [
            "o1",
            "o3",
            "o4"
          ],
          "explanation": "The three ways to concatenate strings are: str1.concat(str2) - the string method that joins strings; str1 + str2 - the concatenation operator; and `${str1}${str2}` - template literals using backticks with embedded expressions. The incorrect options: str1.join(str2) won't work because .join() is an ARRAY method (not available on strings) used to join array elements into a string. concat(str1, str2) as a standalone function doesn't exist - concat() must be called as a method on a string object. All three correct options produce 'JavaScript' from 'Java' and 'Script'.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q27",
          "text": "A developer creates a simple webpage with an input field. When a user enters text and clicks the button, the actual value must be displayed.\n\nHTML:\n<input type='text' value='Hello' name='input'>\n<button type='button'>Display</button>\n\nJavaScript:\nconst button = document.querySelector('button');\nbutton.addEventListener('click', () => {\n  const input = document.querySelector('input');\n  console.log(input.getAttribute('value'));\n});\n\nWhen the user clicks the button, the output is always 'Hello'. What needs to be done to make this code work as expected?",
          "options": [
            {
              "id": "o1",
              "text": "Replace line 04 with console.log(input.value);"
            },
            {
              "id": "o2",
              "text": "Replace line 02 with button.addEventListener('onclick', function() {"
            },
            {
              "id": "o3",
              "text": "Replace line 03 with const input = document.getElementsByName('input');"
            },
            {
              "id": "o4",
              "text": "Replace line 02 with button.addCallback('click', function() {"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Replace line 04 with console.log(input.value). The issue is that getAttribute('value') returns the INITIAL value from the HTML attribute (always 'Hello'), not the current value that the user typed. The input.value property returns the CURRENT value from the DOM, which updates as the user types. The other options are incorrect: 'onclick' is not a valid event name for addEventListener (use 'click'), getElementsByName() returns a collection not a single element and would require indexing, and addCallback() is not a valid method (addEventListener is correct). This is a common trap - HTML attributes vs DOM properties behave differently for form inputs.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q28",
          "text": "Refer to the code below:\n\nlet sayHello = () => {\n  console.log('Hello, world!');\n};\n\nWhich code executes sayHello once, two minutes from now?",
          "options": [
            {
              "id": "o1",
              "text": "delay(sayHello, 120000);"
            },
            {
              "id": "o2",
              "text": "setInterval(sayHello, 120000);"
            },
            {
              "id": "o3",
              "text": "setTimeout(sayHello(), 120000);"
            },
            {
              "id": "o4",
              "text": "setTimeout(sayHello, 120000);"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Use setTimeout(sayHello, 120000) to execute the function ONCE after 120,000 milliseconds (2 minutes). The key is to pass the function REFERENCE (sayHello) not invoke it (sayHello()). The incorrect options: delay() is not a built-in JavaScript function; setInterval() would execute the function repeatedly every 2 minutes, not just once; and setTimeout(sayHello(), 120000) invokes the function IMMEDIATELY and passes its return value (undefined) to setTimeout, which doesn't work. Always pass function references to setTimeout/setInterval without parentheses, or use arrow functions if you need to pass arguments.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q29",
          "text": "Refer to the code below:\n\nfunction changeValue(param) {\n  param = 5;\n}\nlet a = 10;\nlet b = 5;\nchangeValue(b);\nconst result = a + ' - ' + b;\n\nWhat is the value of result when code executes?",
          "options": [
            {
              "id": "o1",
              "text": "10 - 5"
            },
            {
              "id": "o2",
              "text": "10 - 10"
            },
            {
              "id": "o3",
              "text": "5 - 5"
            },
            {
              "id": "o4",
              "text": "5 - 10"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The result is '10 - 5'. This demonstrates that primitive values (numbers, strings, booleans) are passed by VALUE in JavaScript, not by reference. When changeValue(b) is called, the value 5 is COPIED into the parameter 'param'. Inside the function, param = 5 changes the LOCAL copy, but has NO effect on the original variable b outside the function. After the function completes, b still equals 5, so a + ' - ' + b evaluates to '10 - 5'. This is different from objects, which are passed by reference. Understanding pass-by-value vs pass-by-reference is crucial for predicting function behavior.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q30",
          "text": "A class was written to represent items for purchase in an online store. There is a new requirement to implement a description method. Given the code:\n\nclass Item {\n  constructor(name, price) { this.name = name; }\n}\nclass SaleItem extends Item {\n  constructor(name, price, discount) { super(name); }\n}\n\nlet regItem = new Item('Scarf', 55);\nlet saleItem = new SaleItem('Shirt', 80, -1);\nItem.prototype.description = function() { return 'This is a ' + this.name; }\nconsole.log(regItem.description());\nconsole.log(saleItem.description());\nSaleItem.prototype.description = function() { return 'This is a discounted ' + this.name; }\nconsole.log(regItem.description());\nconsole.log(saleItem.description());\n\nWhat is the output?",
          "options": [
            {
              "id": "o1",
              "text": "This is a Scarf, This is a Shirt, This is a Scarf, This is a discounted Shirt"
            },
            {
              "id": "o2",
              "text": "This is a Scarf, Uncaught TypeError: saleItem.description is not a function, This is a Shirt, This is a discounted Shirt"
            },
            {
              "id": "o3",
              "text": "This is a Scarf, Uncaught TypeError: saleItem.description is not a function, This is a Scarf, This is a discounted Shirt"
            },
            {
              "id": "o4",
              "text": "This is a Scarf, This is a Shirt, This is a discounted Scarf, This is a discounted Shirt"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The output is: 'This is a Scarf', 'This is a Shirt', 'This is a Scarf', 'This is a discounted Shirt'. Here's the sequence: 1) Item.prototype.description is defined, making it available to ALL Item instances and subclasses. 2) regItem.description() outputs 'This is a Scarf' - uses Item.prototype. 3) saleItem.description() outputs 'This is a Shirt' - SaleItem inherits from Item, so it also uses Item.prototype.description. 4) SaleItem.prototype.description is defined, overriding the inherited method ONLY for SaleItem instances. 5) regItem.description() still outputs 'This is a Scarf' - regItem is an Item, so it uses Item.prototype. 6) saleItem.description() now outputs 'This is a discounted Shirt' - uses the new SaleItem.prototype.description. This demonstrates prototype chain inheritance and method overriding.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q31",
          "text": "Which code statement correctly retrieves and returns an object from localStorage?",
          "options": [
            {
              "id": "o1",
              "text": "const retrieveFromLocalStorage = () => { return JSON.stringify(window.localStorage.getItem(storageKey)); }"
            },
            {
              "id": "o2",
              "text": "const retrieveFromLocalStorage = (storageKey) => { return JSON.parse(window.localStorage.getItem(storageKey)); }"
            },
            {
              "id": "o3",
              "text": "const retrieveFromLocalStorage = (storageKey) => { return window.localStorage[storageKey]; }"
            },
            {
              "id": "o4",
              "text": "const retrieveFromLocalStorage = (storageKey) => { return window.localStorage.getItem(storageKey); }"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Use JSON.parse(window.localStorage.getItem(storageKey)) to retrieve and convert objects. localStorage stores everything as strings, so objects must be converted back using JSON.parse(). The function also needs a parameter (storageKey) to know which item to retrieve. The incorrect options either: use JSON.stringify() which would double-stringify (making it a string of a string), only retrieve the string without parsing it back to an object (getItem returns a string), or access localStorage as an array (while this works, it still returns a string that needs parsing). Always parse retrieved localStorage data to restore objects to their original form.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q32",
          "text": "Refer to the following code:\n\nlet sampleText = 'The quick brown fox jumps';\n\nA developer needs to determine if a certain substring is part of a string. Which three expressions return true for the given substring? Choose 3 answers",
          "options": [
            {
              "id": "o1",
              "text": "sampleText.includes(' fox ');"
            },
            {
              "id": "o2",
              "text": "sampleText.includes('fox');"
            },
            {
              "id": "o3",
              "text": "sampleText.includes(' quick ', 4);"
            },
            {
              "id": "o4",
              "text": "sampleText.includes(' Fox ', 3);"
            },
            {
              "id": "o5",
              "text": "sampleText.includes(' quick ') !== -1;"
            }
          ],
          "correct": [
            "o1",
            "o2",
            "o5"
          ],
          "explanation": "Three expressions return true: sampleText.includes(' fox ') - the substring ' fox ' (with spaces before and after) exists in the string; sampleText.includes('fox') - 'fox' without spaces is found within 'fox' in the text; and sampleText.includes(' quick ') !== -1 - while includes() returns a boolean (true), comparing it with !== -1 still evaluates to true. The incorrect options: sampleText.includes(' Fox ', 3) fails because includes() is case-sensitive ('Fox' with capital F doesn't match 'fox'), and sampleText.includes(' quick ', 4) fails because it starts searching from index 4, but ' quick ' starts at index 3 (before the search start position).",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q33",
          "text": "Refer to the code below:\n\nfor(let number = 2; number <= 5; number += 1) {\n  // insert code statement here\n}\n\nThe developer needs to insert a code statement with these requirements:\n1. Does NOT require an import\n2. Logs an error when the boolean statement evaluates to false\n3. Works in both the browser and Node.js\n\nWhich meets the requirements?",
          "options": [
            {
              "id": "o1",
              "text": "console.error(number % 2 === 0);"
            },
            {
              "id": "o2",
              "text": "assert(number % 2 === 0);"
            },
            {
              "id": "o3",
              "text": "console.assert(number % 2 === 0);"
            },
            {
              "id": "o4",
              "text": "console.debug(number % 2 === 0);"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Use console.assert(number % 2 === 0). The console.assert() method meets all requirements: 1) It doesn't require any import (available globally in both environments), 2) It logs an error message ONLY when the boolean condition evaluates to FALSE (if the assertion fails), and 3) It works in both browser and Node.js. The incorrect options: console.error() always logs regardless of the condition (doesn't conditionally log only on false), assert() without console would require importing Node.js assert module (violates requirement #1), and console.debug() logs the value but doesn't specifically log an error when the condition is false. console.assert is specifically designed for validation testing.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q34",
          "text": "Refer to the code snippet below:\n\nlet array = [1, 2, 3, 4, 4, 5, 4, 4];\nfor(let i = 0; i < array.length; i++) {\n  if(array[i] === 4) {\n    array.splice(i, 1);\n  }\n}\n\nWhat is the value of the array after the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "[1, 2, 3, 5]"
            },
            {
              "id": "o2",
              "text": "[1, 2, 3, 4, 4, 5, 4]"
            },
            {
              "id": "o3",
              "text": "[1, 2, 3, 4, 5, 4, 4]"
            },
            {
              "id": "o4",
              "text": "[1, 2, 3, 4, 5, 4]"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The result is [1, 2, 3, 4, 5, 4]. This is a classic bug when modifying arrays during iteration. Here's what happens: Starting array is [1,2,3,4,4,5,4,4]. When i=3, array[3]=4 is found and removed via splice(), creating [1,2,3,4,5,4,4]. However, after removing an element, all subsequent elements shift LEFT by one position. The loop then increments i to 4, which now points to 5 (the original array[4]=4 shifted to position 3, getting SKIPPED). This pattern repeats, skipping every other 4. The final array still contains two 4's that were skipped: [1,2,3,4,5,4]. To fix this, either decrement i after splice (i--), iterate backwards, or use filter().",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q35",
          "text": "Refer to the following code:\n\nlet array = [1, 2, 3, 4, 4, 5, 4, 4];\nfor(let i = 0; i < array.length; i++) {\n  if(array[i] === 4) {\n    array.splice(i, 1);\n    i--;\n  }\n}\nalert(array);\n\nWhat is the value of array after the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "[1, 2, 3, 5]"
            },
            {
              "id": "o2",
              "text": "[1, 2, 3, 4, 5]"
            },
            {
              "id": "o3",
              "text": "[1, 2, 3, 4, 4, 5]"
            },
            {
              "id": "o4",
              "text": "[1, 2, 3, 4, 5, 4]"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The result is [1, 2, 3, 5]. This code CORRECTLY removes all instances of 4 by adding i-- after splice(). Here's how it works: When a 4 is found and removed, all subsequent elements shift left by one position. The i-- statement decrements the counter, so when the loop increments i at the end of the iteration (i++), it effectively stays at the same index, checking the element that shifted into the current position. For example, when the first 4 at index 3 is removed, the second 4 shifts to index 3. The i-- makes i=2, then i++ makes i=3, correctly checking the shifted 4. This compensation ensures no elements are skipped, removing all four 4's to produce [1,2,3,5].",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q36",
          "text": "Refer to the code below:\n\nconst searchText = 'Yay! Salesforce is amazing!';\nlet result1 = searchText.search(/sales/i);\nlet result2 = searchText.search(/sales/);\nconsole.log(result1);\nconsole.log(result2);\n\nAfter running this code, which result is displayed on the console?",
          "options": [
            {
              "id": "o1",
              "text": "> 5 > undefined"
            },
            {
              "id": "o2",
              "text": "> true > false"
            },
            {
              "id": "o3",
              "text": "> 5 > -1"
            },
            {
              "id": "o4",
              "text": "> 5 > 0"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "The output is: 5 and -1. The search() method returns the INDEX of the first match, or -1 if not found (not a boolean). result1 uses /sales/i where the 'i' flag makes it case-INSENSITIVE, so it matches 'Sales' in 'Salesforce' starting at index 5 (Y-a-y-!-space = 0-1-2-3-4, then 'Sales' starts at 5). result2 uses /sales/ which is case-SENSITIVE, looking for lowercase 'sales' which doesn't exist in the string (only 'Sales' with capital S exists), so it returns -1. The incorrect options either show boolean values (search returns numbers), undefined (which doesn't happen), or wrong indices.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q37",
          "text": "A developer implements and calls the following code when an application state change occurs:\n\nconst onStateChange = (newPageState) => {\n  window.history.pushState(newPageState, '', null);\n}\n\nIf the back button is clicked after this method is executed, what can a developer expect?",
          "options": [
            {
              "id": "o1",
              "text": "A navigate event is fired with a state property that details the previous application state."
            },
            {
              "id": "o2",
              "text": "The page reloads and all Javascript is reinitialized."
            },
            {
              "id": "o3",
              "text": "The page is navigated away from and the previous page in the browser's history is loaded."
            },
            {
              "id": "o4",
              "text": "A popstate event is fired with a state property that details the application's last state."
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "A popstate event is fired with the previous state. The pushState() method adds an entry to the browser's history stack WITHOUT reloading the page, allowing single-page applications to manage browser history. When the back button is clicked, the browser fires a 'popstate' event on the window object, and the event's state property contains the state object from the previous history entry. The incorrect options: there's no 'navigate' event in this context, the page does NOT reload (pushState is specifically designed to avoid reloads), and the page doesn't navigate away (it stays on the same page but the history changes). The developer can listen for 'popstate' events to handle back/forward button clicks and restore the application state accordingly.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q38",
          "text": "Refer to the following code:\n\nnew Promise((resolve, reject) => {\n  const fraction = Math.random();\n  if(fraction > 0.5) reject('fraction > 0.5, ' + fraction);\n  resolve(fraction);\n})\n.then(() => console.log('resolved'))\n.catch((error) => console.error(error))\n.finally(() => console.log('when am I called?'));\n\nWhen does Promise.finally get called?",
          "options": [
            {
              "id": "o1",
              "text": "When resolved"
            },
            {
              "id": "o2",
              "text": "When resolved and settled"
            },
            {
              "id": "o3",
              "text": "When resolved or rejected"
            },
            {
              "id": "o4",
              "text": "When rejected"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Promise.finally() is called when the promise is resolved OR rejected - it ALWAYS executes regardless of the outcome. The finally() block runs after either then() or catch(), making it perfect for cleanup operations that should happen whether the promise succeeds or fails (like hiding loading spinners, closing connections, etc.). In this code, if fraction > 0.5, the promise rejects and catch() runs, then finally() runs. If fraction <= 0.5, the promise resolves and then() runs, then finally() runs. The term 'settled' means the promise is no longer pending (either resolved or rejected), so 'when resolved or rejected' is the most accurate description of when finally executes.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q39",
          "text": "Refer to the following object:\n\nconst cat = {\n  firstName: 'Fancy',\n  lastName: 'Whiskers',\n  get fullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nHow can a developer access the fullName property for cat?",
          "options": [
            {
              "id": "o1",
              "text": "cat.fullName"
            },
            {
              "id": "o2",
              "text": "cat.fullName()"
            },
            {
              "id": "o3",
              "text": "cat.get.fullName"
            },
            {
              "id": "o4",
              "text": "cat.function.fullName()"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Access it as cat.fullName (no parentheses). Getters are defined with the 'get' keyword but are accessed like regular properties, NOT like methods. When you access cat.fullName, JavaScript automatically calls the getter function and returns its result. The incorrect options: cat.fullName() treats it like a method and would throw an error 'fullName is not a function', cat.get.fullName tries to access a non-existent 'get' property, and cat.function.fullName uses invalid syntax. Getters provide a way to compute property values dynamically while maintaining property-like syntax, making the code cleaner and more intuitive.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q40",
          "text": "A developer wants to use a module named universalContainersLib and then call functions from it. How should a developer import every function from the module and then call the functions foo and bar?",
          "options": [
            {
              "id": "o1",
              "text": "import {foo, bar} from '/path/universalContainersLib.js'; foo(); bar();"
            },
            {
              "id": "o2",
              "text": "import * from '/path/universalContainersLib.js'; universalContainersLib.foo(); universalContainersLib.bar();"
            },
            {
              "id": "o3",
              "text": "import * as lib from '/path/universalContainersLib.js'; lib.foo(); lib.bar();"
            },
            {
              "id": "o4",
              "text": "import all from '/path/universalContainersLib.js'; universalContainersLib.foo(); universalContainersLib.bar();"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Use import * as lib from '/path/universalContainersLib.js' then call lib.foo() and lib.bar(). The 'import * as' syntax imports ALL exports from a module and groups them under a namespace (in this case 'lib'). This allows you to access all exported functions, variables, and classes through that namespace object. The incorrect options: import {foo, bar} only imports specific named exports (not 'every function'), import * without 'as' is invalid syntax (you must specify an alias), and 'import all' is not valid JavaScript syntax. The namespace approach prevents naming conflicts and makes it clear where functions come from.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q41",
          "text": "Why would a developer specify a package.json as a devDependency instead of a dependency?",
          "options": [
            {
              "id": "o1",
              "text": "It should be bundled when the package is published."
            },
            {
              "id": "o2",
              "text": "It is required by the application in production."
            },
            {
              "id": "o3",
              "text": "It is only needed for local development and testing."
            },
            {
              "id": "o4",
              "text": "Other required packages depend on it for development."
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "devDependencies are for packages only needed during local development and testing, not in production. Examples include: testing frameworks (Jest, Mocha), build tools (Webpack, Babel), linters (ESLint), and documentation generators. These tools are used by developers but aren't required when the application runs in production. The incorrect options: packages needed in production belong in 'dependencies' (not devDependencies), bundling happens regardless of dependency type, and while other packages may depend on devDependencies during development, that's not the primary reason for the distinction. Using devDependencies correctly reduces production bundle size and clarifies which packages are essential for runtime vs development.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q42",
          "text": "Refer to code below:\n\nconst objBook = {\n  title: 'Javascript',\n};\nObject.preventExtensions(objBook);\nconst newObjBook = objBook;\nnewObjBook.author = 'Robert';\n\nWhat are the values of objBook and newObjBook respectively?",
          "options": [
            {
              "id": "o1",
              "text": "{author: 'Robert', title: 'JavaScript'}, undefined"
            },
            {
              "id": "o2",
              "text": "{title: 'JavaScript'}, {title: 'JavaScript'}"
            },
            {
              "id": "o3",
              "text": "{author: 'Robert', title: 'JavaScript'}, {author: 'Robert', title: 'JavaScript'}"
            },
            {
              "id": "o4",
              "text": "{author: 'Robert'}, {author: 'Robert', title: 'JavaScript'}"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Both variables contain {title: 'JavaScript'}. Object.preventExtensions() prevents NEW properties from being added to an object, but allows modification of existing properties. When newObjBook.author = 'Robert' executes, it attempts to add a new property 'author', which is silently ignored (in non-strict mode) or throws an error (in strict mode). The key point: newObjBook = objBook creates a REFERENCE, not a copy, so both variables point to the same object in memory. Since the 'author' property couldn't be added due to preventExtensions(), and both variables reference the same object, they both contain only {title: 'JavaScript'}. The object remains unchanged because extension was prevented.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q43",
          "text": "A developer wrote a test for sum3 function that sums first three numbers. The test passes. A different developer changed sum3 to sum all numbers. Which two results occur when running the test on the updated sum3 function? Choose 2 answers\n\nlet res = sum3([1, 2, 3]);\nconsole.assert(res === 6);\nres = sum3([1, 2, 3, 4]);\nconsole.assert(res === 6);",
          "options": [
            {
              "id": "o1",
              "text": "The line 02 assertion passes."
            },
            {
              "id": "o2",
              "text": "The line 02 assertion fails."
            },
            {
              "id": "o3",
              "text": "The line 05 assertion passes."
            },
            {
              "id": "o4",
              "text": "The line 05 assertion fails."
            }
          ],
          "correct": [
            "o1",
            "o4"
          ],
          "explanation": "The line 02 assertion passes AND the line 05 assertion fails. Here's why: The original sum3 function summed only the FIRST THREE numbers. The test was written to validate this behavior with two test cases. After the function was changed to sum ALL numbers: Line 02 test sum3([1,2,3]) still returns 6 (1+2+3=6), so the assertion passes - this test can't detect the change because the array only has 3 elements. Line 05 test sum3([1,2,3,4]) now returns 10 (1+2+3+4=10), but the assertion expects 6, so it FAILS. This demonstrates why tests need comprehensive coverage - the first test alone would give false confidence that the function still works correctly when it actually behaves differently now.",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q44",
          "text": "Which statement can a developer apply to increment the browser's navigation history without a page refresh?",
          "options": [
            {
              "id": "o1",
              "text": "window.history.replaceState(newStateObject, '', null);"
            },
            {
              "id": "o2",
              "text": "window.history.pushState(newStateObject, '', null);"
            },
            {
              "id": "o3",
              "text": "window.history.pushState(newStateObject);"
            },
            {
              "id": "o4",
              "text": "window.history.state.push(newStateObject);"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Use window.history.pushState(newStateObject, '', null) to INCREMENT the browser history. pushState() ADDS a new entry to the browser's history stack, moving forward one step in history without causing a page reload. The method takes three parameters: state object (data to store), title (mostly ignored by browsers, use empty string), and URL (optional, use null to keep current URL). The incorrect options: replaceState() MODIFIES the current history entry without incrementing (staying at the same position), pushState() requires all three parameters (leaving out parameters causes errors), and window.history.state.push() is invalid (state is a property, not an object with a push method). pushState is essential for single-page applications to manage browser navigation.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q45",
          "text": "What is the result of the code block?",
          "options": [
            {
              "id": "o1",
              "text": "The console logs 'flag' and then an error is thrown."
            },
            {
              "id": "o2",
              "text": "The console logs 'flag' and another flag."
            },
            {
              "id": "o3",
              "text": "An error is thrown."
            },
            {
              "id": "o4",
              "text": "The console logs only 'flag'."
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The console logs only 'flag'. Without seeing the complete code block, based on typical try-catch behavior, this suggests the code has a try block that logs 'flag' and then encounters an error that is caught by a catch block, preventing the error from propagating. The catch block handles the error silently (without logging another flag or re-throwing). This demonstrates proper error handling where errors are caught and handled gracefully, preventing application crashes while only executing the successful portion of the code (logging 'flag'). If there were a finally block or multiple flags, they would appear in the output, but the result shows only one 'flag' log.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q46",
          "text": "Given code below:\n\nsetTimeout(() => {\n  console.log(1);\n}, 0);\nconsole.log(2);\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(console.log(3));\n  }, 1000);\n}).catch(() => {\n  console.log(4);\n});\nconsole.log(5);\n\nWhat is logged to the console?",
          "options": [
            {
              "id": "o1",
              "text": "1 2 5 3 4"
            },
            {
              "id": "o2",
              "text": "2 5 1 3 4"
            },
            {
              "id": "o3",
              "text": "2 1 4 3 5"
            },
            {
              "id": "o4",
              "text": "1 2 4 3 5"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The sequence is 2 5 1 3 4. Execution flow: 1) Synchronous code executes first: console.log(2) outputs 2, then console.log(5) outputs 5. 2) The setTimeout with 0ms delay is placed in the macrotask queue and executes after the call stack clears, logging 1. 3) The Promise constructor executes immediately but schedules a setTimeout for 1000ms. 4) After 1000ms, the setTimeout inside the Promise executes: console.log(3) outputs 3, then the promise rejects. 5) The .catch() handler runs immediately after rejection, logging 4. Key concept: Even with 0ms delay, setTimeout always executes AFTER synchronous code due to the event loop. The promise rejection and catch happen together after the 1000ms timeout.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q47",
          "text": "Given the code below:\n\nfunction myFunction() {\n  a = 5;\n  var b = 1;\n}\nmyFunction();\nconsole.log(a);\nconsole.log(b);\n\nWhat is the expected output?",
          "options": [
            {
              "id": "o1",
              "text": "Both lines 08 and 09 are executed, but values outputted are undefined."
            },
            {
              "id": "o2",
              "text": "Both lines 08 and 09 are executed, and the variables are outputted."
            },
            {
              "id": "o3",
              "text": "Line 08 throws an error, therefore line 09 is never executed."
            },
            {
              "id": "o4",
              "text": "Line 08 outputs the variable, but line 09 throws an error."
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Line 08 outputs the variable (5), but line 09 throws an error. Here's why: Inside myFunction(), 'a = 5' creates an IMPLICIT GLOBAL variable because no declaration keyword (var, let, const) is used - this is a major pitfall in JavaScript and bad practice. However, 'var b = 1' creates a FUNCTION-SCOPED variable that only exists inside myFunction(). After the function executes: console.log(a) works because 'a' was accidentally created as a global variable and outputs 5. console.log(b) throws 'ReferenceError: b is not defined' because 'b' only exists within the function scope and is not accessible outside. This demonstrates the importance of always using var/let/const to avoid creating accidental global variables. In strict mode ('use strict'), the implicit global would also throw an error.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q48",
          "text": "myArray can have one level, two levels, or more levels. Which statement flattens myArray when it can be arbitrarily nested?",
          "options": [
            {
              "id": "o1",
              "text": "[].concat(...myArray);"
            },
            {
              "id": "o2",
              "text": "myArray.flat(Infinity);"
            },
            {
              "id": "o3",
              "text": "myArray.reduce((prev, curr) => prev.concat(curr), []);"
            },
            {
              "id": "o4",
              "text": "myArray.join(',').split(',');"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Use myArray.flat(Infinity) to flatten arrays to ANY depth. The flat() method with Infinity as the depth parameter recursively flattens nested arrays no matter how many levels deep they are. For example: [[1,[2,[3,[4]]]]] becomes [1,2,3,4]. The incorrect options: [].concat(...myArray) and reduce with concat only flatten ONE level deep ([[1,[2,3]]] becomes [1,[2,3]], not [1,2,3]). myArray.join(',').split(',') converts everything to strings, losing data types and structure - not a true flatten operation. For deeply nested arrays with unknown depth, flat(Infinity) is the only reliable solution, though for known depths you can specify a number like flat(2).",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q49",
          "text": "Universal Containers notices its search application makes a network request each time a key is pressed. UC decides to implement a debounce function. What are three key steps to implement this debounce function? Choose 3 answers",
          "options": [
            {
              "id": "o1",
              "text": "If there is an existing setTimeout and the search string changes, allow the existing setTimeout to finish, and do not enqueue a new setTimeout."
            },
            {
              "id": "o2",
              "text": "If there is an existing setTimeout and the search string changes, cancel the existing setTimeout using the persisted timerId and replace it with a new setTimeout."
            },
            {
              "id": "o3",
              "text": "Store the timerId of the setTimeout last enqueued by the search string change handler."
            },
            {
              "id": "o4",
              "text": "Ensure that the network request has the property debounce set to true."
            },
            {
              "id": "o5",
              "text": "When the search string changes, enqueue the request within a setTimeout."
            }
          ],
          "correct": [
            "o2",
            "o3",
            "o5"
          ],
          "explanation": "The three key steps for debouncing are: 1) Store the timerId of the setTimeout - you need to persist this ID in a variable accessible to the handler so you can reference it later. 2) When the search string changes and there's an existing setTimeout, CANCEL it using clearTimeout(timerId) and replace it with a new setTimeout - this prevents the old request from firing. 3) Enqueue the network request within a setTimeout - this delays execution until the user stops typing. The incorrect options: allowing the existing setTimeout to finish defeats the purpose of debouncing (you'd still make unnecessary requests), and setting a 'debounce' property on the request is not how debouncing works - it's about timing control, not request properties. Debouncing reduces API calls by waiting for a pause in user input.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q50",
          "text": "Given the following code:\n\ncounter = 0;\nconst logCounter = () => {\n  console.log(counter);\n};\nlogCounter();\nsetTimeout(logCounter, 1100);\nsetInterval(() => {\n  counter++;\n  logCounter();\n}, 1000);\n\nWhat is logged by the first four log statements?",
          "options": [
            {
              "id": "o1",
              "text": "0 1 1 2"
            },
            {
              "id": "o2",
              "text": "0 1 2 2"
            },
            {
              "id": "o3",
              "text": "0 0 1 2"
            },
            {
              "id": "o4",
              "text": "0 1 2 3"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The sequence is 0 1 1 2. Timeline: 1) logCounter() executes immediately, logging 0 (counter starts at 0). 2) setTimeout schedules logCounter for 1100ms later. 3) setInterval schedules the arrow function to run every 1000ms starting at 1000ms. 4) At 1000ms: setInterval fires, increments counter to 1, then calls logCounter() which logs 1. 5) At 1100ms: setTimeout fires, calling logCounter() which logs 1 (counter is still 1). 6) At 2000ms: setInterval fires again, increments counter to 2, then calls logCounter() which logs 2. Key concept: The setTimeout at 1100ms happens BETWEEN the first (1000ms) and second (2000ms) setInterval executions, so it sees counter=1. This demonstrates the interleaving of timed events in JavaScript's event loop.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q51",
          "text": "Refer to the following code:\n\nclass Vehicle {\n  constructor(plate) {\n    this.plate = plate;\n  }\n}\nclass Truck extends Vehicle {\n  constructor(plate, weight) {\n    //Missing code\n    this.weight = weight;\n  }\n  displayWeight() {\n    console.log(`The truck ${this.plate} has a weight of ${this.weight}lb.`);\n  }\n}\nlet myTruck = new Truck('123AB', 5000);\nmyTruck.displayWeight();\n\nWhich statement should be added to missing code?",
          "options": [
            {
              "id": "o1",
              "text": "super.plate = plate;"
            },
            {
              "id": "o2",
              "text": "super(plate);"
            },
            {
              "id": "o3",
              "text": "Vehicle.plate = plate;"
            },
            {
              "id": "o4",
              "text": "this.plate = plate;"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Add super(plate) to call the parent class constructor. In JavaScript class inheritance, when a child class (Truck) extends a parent class (Vehicle), the child's constructor MUST call super() before accessing 'this'. The super(plate) call invokes Vehicle's constructor, which initializes this.plate. You must pass the required parent constructor parameters (plate) to super(). The incorrect options: super.plate = plate treats super like an object (it's a keyword for calling parent methods), Vehicle.plate = plate creates a static property on the class (not an instance property), and this.plate = plate would work but you still need super() called first or you'll get 'ReferenceError: Must call super constructor before accessing this'. Always call super() as the FIRST statement in a derived class constructor.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q52",
          "text": "Refer to the code below:\n\nfunction Person(firstName, lastName, eyeColor) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n  this.eyeColor = eyeColor;\n}\nPerson.job = 'Developer';\nconst myFather = new Person('John', 'Doe');\nconsole.log(myFather.job);\n\nWhat is the output after the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "ReferenceError: assignment to undeclared variable 'Person'"
            },
            {
              "id": "o2",
              "text": "undefined"
            },
            {
              "id": "o3",
              "text": "Developer"
            },
            {
              "id": "o4",
              "text": "ReferenceError: eyeColor is not defined"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The output is undefined. Person.job = 'Developer' creates a STATIC property on the Person constructor function itself, not on instances created by it. When you access myFather.job, JavaScript looks for 'job' on the instance (not found), then checks the prototype chain (not found), and returns undefined. To make 'job' available on instances, you would need to either: 1) Add it in the constructor: this.job = 'Developer', or 2) Add it to the prototype: Person.prototype.job = 'Developer'. The other potential errors don't occur: Person is properly declared as a function, and eyeColor being undefined in the instance (since only two arguments were passed) doesn't cause an error - it just makes myFather.eyeColor = undefined. This demonstrates the difference between static properties and instance properties.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q53",
          "text": "Which two statements correctly execute the runParallel() async function that returns a promise? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "runParallel().then(data);"
            },
            {
              "id": "o2",
              "text": "runParallel().then(function(data) { return data; });"
            },
            {
              "id": "o3",
              "text": "async runParallel().then(data);"
            },
            {
              "id": "o4",
              "text": "await runParallel();"
            }
          ],
          "correct": [
            "o2",
            "o4"
          ],
          "explanation": "Two correct ways: runParallel().then(function(data) { return data; }) uses a proper callback function, and await runParallel() waits for the promise to resolve. The incorrect options: runParallel().then(data) is invalid syntax - .then() requires a FUNCTION, not just a parameter name (should be .then(data => ...) or .then(function(data) {...})). async runParallel().then(data) puts 'async' in the wrong place - 'async' is for function DECLARATIONS, not function CALLS. To use await, the containing function must be declared async, but await is the correct way to execute the promise itself. Both .then() with a proper callback and await are valid promise execution patterns.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q54",
          "text": "A developer has a formatName function that takes two arguments, firstName and lastName. They want to schedule the function to run once after five seconds. What is the correct syntax?",
          "options": [
            {
              "id": "o1",
              "text": "setTimeout(formatName(), 5000, 'John', 'Doe');"
            },
            {
              "id": "o2",
              "text": "setTimeout(() => { formatName('John', 'Doe'); }, 5000);"
            },
            {
              "id": "o3",
              "text": "setTimeout(formatName, 5000, 'John', 'Doe');"
            },
            {
              "id": "o4",
              "text": "setTimeout(formatName('John', 'Doe'), 5000);"
            }
          ],
          "correct": [
            "o2",
            "o3"
          ],
          "explanation": "Two correct approaches: setTimeout(() => { formatName('John', 'Doe'); }, 5000) wraps the function call in an arrow function, and setTimeout(formatName, 5000, 'John', 'Doe') passes the function reference followed by delay and then arguments (setTimeout automatically passes additional parameters to the function). The incorrect options: setTimeout(formatName(), 5000, 'John', 'Doe') and setTimeout(formatName('John', 'Doe'), 5000) both INVOKE formatName IMMEDIATELY (the parentheses execute it right away), passing its return value (probably undefined) to setTimeout instead of the function itself. This is a common mistake - always pass function references without parentheses to setTimeout, or wrap calls in arrow functions.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q55",
          "text": "A developer wrote a test for sum3 function. The function was changed to sum only the first two numbers. Which two results occur? Choose 2 answers\n\nlet res = sum3([1, 2, 3]);\nconsole.assert(res === 6);\n\nres = sum3([1, 2, 3, 4]);\nconsole.assert(res === 6);",
          "options": [
            {
              "id": "o1",
              "text": "The line 02 assertion fails."
            },
            {
              "id": "o2",
              "text": "The line 02 assertion passes."
            },
            {
              "id": "o3",
              "text": "The line 05 assertion passes."
            },
            {
              "id": "o4",
              "text": "The line 05 assertion fails."
            }
          ],
          "correct": [
            "o1",
            "o4"
          ],
          "explanation": "If sum3 was changed to sum only the FIRST TWO numbers, then: for [1,2,3] the sum is 1+2=3 (NOT 6, so line 02 assertion FAILS), and for [1,2,3,4] the sum is also 1+2=3 (NOT 6, so line 05 assertion FAILS). Both assertions expect 6 but get 3 because the function now ignores elements after the second. The incorrect options suggesting either assertion passes are wrong - the modified sum3 function breaks BOTH test cases since neither array's first two elements sum to 6.",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q56",
          "text": "Given the following code, what is the value of x?\n\nlet x = '15' + (10 * 2);",
          "options": [
            {
              "id": "o1",
              "text": "50"
            },
            {
              "id": "o2",
              "text": "1520"
            },
            {
              "id": "o3",
              "text": "3020"
            },
            {
              "id": "o4",
              "text": "35"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Due to operator precedence, multiplication happens first: 10 * 2 = 20. Then the + operator is evaluated left-to-right: '15' + 20. Since one operand is a string, JavaScript converts 20 to '20' and concatenates: '15' + '20' = '1520'. The incorrect options: 50 would require numeric addition (15 + 20), 3020 incorrectly assumes '15' becomes 30, and 35 incorrectly assumes string-to-number conversion happens before addition. When the + operator encounters a string operand, it ALWAYS performs concatenation, not addition.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q57",
          "text": "A developer wants to catch any error that countSheep() may throw and pass it to handleError(). What is the correct implementation of the try...catch?",
          "options": [
            {
              "id": "o1",
              "text": "try { countSheep(); } catch(e) { handleError(e); }"
            },
            {
              "id": "o2",
              "text": "try { setTimeout(function() { countSheep(); }, 1000); } catch(e) { handleError(e); }"
            },
            {
              "id": "o3",
              "text": "try { countSheep(); } finally { handleError(e); }"
            },
            {
              "id": "o4",
              "text": "try { countSheep(); } finally { handleError(e); }"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The correct syntax is try { countSheep(); } catch(e) { handleError(e); } - the catch block receives the error parameter 'e' and can handle it. The incorrect options: try...finally does NOT catch errors - finally blocks run regardless of whether an error occurred, but they don't receive an error parameter (so 'e' would be undefined). The setTimeout option won't work because errors thrown inside setTimeout callbacks are NOT caught by surrounding try-catch blocks - asynchronous errors require different handling (promises, async/await, or error callbacks).",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q58",
          "text": "A developer is trying to handle an error within a function. Which code segment shows the correct approach to handle an error without propagating it elsewhere?",
          "options": [
            {
              "id": "o1",
              "text": "try { doSomething(); } catch(error) { return error; }"
            },
            {
              "id": "o2",
              "text": "try { doSomething(); } catch(error) { throw new Error('Error found'); }"
            },
            {
              "id": "o3",
              "text": "try { doSomething(); } catch(error) { console.error(error); }"
            },
            {
              "id": "o4",
              "text": "try { doSomething(); } catch(error) { processError(error); }"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "To handle an error without propagating it, you must catch it and process it WITHOUT throwing or returning it. The correct option catch(error) { processError(error); } catches the error, processes it via a handler function, and then continues normal execution. The incorrect options: catch(error) { return error; } returns the error to the caller (propagating it as a return value), catch(error) { throw new Error('Error found'); } explicitly re-throws an error (propagating it up the call stack), and catch(error) { console.error(error); } only logs the error but doesn't handle it meaningfully (though it doesn't propagate, it also doesn't process/recover from the error). The key distinction is between logging vs. handling, and ensuring no throw/return occurs.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q59",
          "text": "Given the expressions var1 and var2, what are two valid ways to return the concatenation of the two expressions and ensure it is string? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "var1.toString() + var2.toString()"
            },
            {
              "id": "o2",
              "text": "String(var1).concat(var2)"
            },
            {
              "id": "o3",
              "text": "var1 + var2"
            },
            {
              "id": "o4",
              "text": "String.concat(var1 + var2)"
            }
          ],
          "correct": [
            "o1",
            "o2"
          ],
          "explanation": "Two methods GUARANTEE string concatenation: var1.toString() + var2.toString() explicitly converts both to strings before using +, and String(var1).concat(var2) converts var1 to string then uses the .concat() method (which coerces var2 to string). The incorrect options: var1 + var2 does NOT ensure string result - if both are numbers, you get numeric addition (5 + 3 = 8, not '53'). String.concat(var1 + var2) is invalid - String (the constructor) has no .concat() method; .concat() exists on string INSTANCES, not the String constructor itself. Always convert at least one operand to string explicitly when concatenation is required.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q60",
          "text": "Refer to the code below: Async function functionUnderTest(isOK) { If (isOK) return 'OK'; Throw new Error('not OK'); } Which assertion accurately tests the above code?",
          "options": [
            {
              "id": "o1",
              "text": "Console.assert (await functionUnderTest(true), ' notOK ')"
            },
            {
              "id": "o2",
              "text": "Console.assert (await functionUnderTest(true), 'OK')"
            },
            {
              "id": "o3",
              "text": "Console.assert (await functionUnderTest(true), ' OK ')"
            },
            {
              "id": "o4",
              "text": "Console.assert (await functionUnderTest(true), ' not OK ')"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "When isOK is true, functionUnderTest returns 'OK' (no spaces). console.assert() checks if the first argument is truthy - if it is, it passes silently. The correct test is console.assert(await functionUnderTest(true), 'OK') which will pass because the function returns 'OK' (truthy), and if it failed, would show the message 'OK'. The incorrect options: 'notOK', ' OK ' (with spaces), and ' not OK ' don't match the actual return value of 'OK'. Note: console.assert syntax is backwards from typical assertions - the SECOND parameter is the FAILURE MESSAGE, not the expected value. For proper testing, use a testing framework like Jest with expect(await functionUnderTest(true)).toBe('OK').",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q61",
          "text": "Refer to the following code: Let obj ={ Foo: 1, Bar: 2 } Let output =[], for(let something in obj{ output.push(something); } console.log(output); What is the output line 11?",
          "options": [
            {
              "id": "o1",
              "text": "[1,2]"
            },
            {
              "id": "o2",
              "text": "[\"foo\",\"bar\"]"
            },
            {
              "id": "o3",
              "text": "[\"foo:1\",\"bar:2\"]"
            },
            {
              "id": "o4",
              "text": "[\"bar\",\"foo\"]"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The for...in loop iterates over the enumerable property NAMES (keys) of an object, not the values. So 'something' will be the strings 'Foo' and 'Bar' (JavaScript normalizes property names to lowercase in certain contexts, but here they remain as defined). The output is ['Foo', 'Bar'] or ['foo', 'bar'] depending on how the keys were defined. The incorrect options: [1, 2] would require iterating over VALUES (use Object.values(obj) or for...of Object.values(obj)), ['foo:1', 'bar:2'] incorrectly concatenates keys and values, and ['bar', 'foo'] has the wrong order (property insertion order is preserved). Note: for...in gives you KEYS as strings, not values.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q62",
          "text": "A developer writers the code below to calculate the factorial of a given number. Function factorial(number) { Return number + factorial(number -1); } factorial(3); What is the result of executing line 04?",
          "options": [
            {
              "id": "o1",
              "text": "0"
            },
            {
              "id": "o2",
              "text": "6"
            },
            {
              "id": "o3",
              "text": "-Infinity"
            },
            {
              "id": "o4",
              "text": "RuntimeError"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "This function has TWO critical bugs: it uses addition (+) instead of multiplication (*), and it lacks a BASE CASE to stop recursion. When factorial(3) runs, it calls factorial(2), which calls factorial(1), factorial(0), factorial(-1), and so on forever. Without a base case (like 'if (number <= 1) return 1'), the recursion never stops and eventually exceeds the call stack limit, throwing a RangeError (stack overflow). The incorrect options: 6 would be correct if the function used multiplication and had a proper base case (3 * 2 * 1 = 6), 0 and -Infinity don't match JavaScript's behavior for stack overflow errors. This is a RuntimeError due to infinite recursion.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q63",
          "text": "Refer to the code below: Let car1 = new Promise((_ , reject) => setTimeout(reject, 2000, \"car 1 crashed in\") Let car2 =new Promise(resolve => setTimeout(resolve, 1500, \"car 2 completed\") Let car3 =new Promise(resolve =>setTimeout(resolve, 3000, \"car 3 completed\") Promise.race(( car1, car2, car3)) .then (value => { Let result = '$(value) the race.';)} .catch(arr => { console.log(\"Race is cancelled.\", err); }); What is the value of result when Promise.race executes?",
          "options": [
            {
              "id": "o1",
              "text": "Car 2 completed the race."
            },
            {
              "id": "o2",
              "text": "Car 1 crashed in the race."
            },
            {
              "id": "o3",
              "text": "Car3 completes the race"
            },
            {
              "id": "o4",
              "text": "Race is cancelled."
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Promise.race() settles (resolves or rejects) with the FIRST promise to complete, regardless of whether it resolves or rejects. Timeline: car2 resolves at 1500ms with 'car 2 completed', car1 rejects at 2000ms, car3 resolves at 3000ms. Since car2 finishes first and RESOLVES successfully, the .then() handler executes with value = 'car 2 completed', setting result = 'car 2 completed the race.' The incorrect options: car1 would only win if it finished first (but 2000ms > 1500ms), car3 finishes last (3000ms), and 'Race is cancelled' only happens if the FIRST promise to complete is a rejection. Promise.race is about speed, not success/failure.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q64",
          "text": "Refer to the code below: const car = { price:100, getPrice:function(){ return this.price; } }; const customCar = Object.create(car); customCar.price = 70; delete customCar.price; const result = customCar.getPrice(); What is the value of result after the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "100"
            },
            {
              "id": "o2",
              "text": "70"
            },
            {
              "id": "o3",
              "text": "undefined"
            },
            {
              "id": "o4",
              "text": "null"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Step-by-step: customCar is created with car as its prototype, then customCar.price = 70 creates an OWN property on customCar (shadowing the prototype's price). When delete customCar.price executes, it removes the OWN property, but does NOT delete the prototype's property. Now customCar.getPrice() looks for 'price' on customCar (not found), then walks up the prototype chain to car.price = 100. The incorrect options: 70 would be correct if delete didn't happen, undefined/null would occur if neither customCar nor its prototype had a price property. Key concept: delete only removes OWN properties, not inherited ones.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q65",
          "text": "Refer to the code below: function foo () { const a =2; function bar() { console.log(a); } return bar; } Why does the function bar have access to variable a?",
          "options": [
            {
              "id": "o1",
              "text": "Outer function's scope"
            },
            {
              "id": "o2",
              "text": "Inner function's scope"
            },
            {
              "id": "o3",
              "text": "Hoisting"
            },
            {
              "id": "o4",
              "text": "Prototype chain"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "This demonstrates CLOSURES - when bar is defined inside foo, it creates a closure that captures the outer function's scope, including the variable 'a'. Even after foo returns, bar retains access to 'a' because closures preserve the lexical environment where they were created. The incorrect options: bar doesn't have its own 'a' (inner function's scope is wrong), hoisting moves declarations but doesn't explain cross-scope access, and prototype chain is for object property inheritance, not variable scope. Closures are why inner functions can access outer function variables even after the outer function has finished executing.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q66",
          "text": "Refer to following code block: Let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,]; Let output =0; For (let num of array){ if (output >0){ Break; } if(num % 2 == 0){ Continue; } Output +=num; } What is the value of output after the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "11"
            },
            {
              "id": "o2",
              "text": "25"
            },
            {
              "id": "o3",
              "text": "16"
            },
            {
              "id": "o4",
              "text": "36"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "The loop processes: 1 (odd, output=0+1=1), 2 (even, continue skips), 3 (odd, output=1+3=4), 4 (even, skip), 5 (odd, output=4+5=9), 6 (even, skip), 7 (odd, output=9+7=16), then checks 'if (output > 0)' which is TRUE (16 > 0), so break exits the loop. Final output is 16. The incorrect options: 11 would require stopping after just the first odd number, 25 would be the sum of ALL odd numbers (1+3+5+7+9+11=36, not 25), and 36 would require processing more numbers. Key insight: the break condition checks AFTER adding to output, so the loop continues accumulating odd numbers until output becomes positive, which happens after the FIRST odd number (1), but the check occurs at the START of the next iteration.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q67",
          "text": "Given the code below:\n\nfunction Person(name, email) {\n  this.name = name;\n  this.email = email;\n}\n\nconst john = new Person('John', 'john@email.com');\nconst jane = new Person('Jane', 'jane@email.com');\nconst emily = new Person('Emily', 'emily@email.com');\n\nlet usersList = [john, jane, emily];\n\nWhich method can be used to provide a visual representation of the list of users and to allow sorting by the name or email attribute?",
          "options": [
            {
              "id": "o1",
              "text": "console.table(usersList) ;"
            },
            {
              "id": "o2",
              "text": "console.group(usersList) ;"
            },
            {
              "id": "o3",
              "text": "console.groupCollapsed (usersList) ;"
            },
            {
              "id": "o4",
              "text": "console.info(usersList) ;"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "console.table() renders arrays and objects in a tabular format with columns that can be clicked to sort by that property. For usersList, it creates a table with columns for name and email, allowing visual inspection and interactive sorting. The incorrect options: console.group() and console.groupCollapsed() create collapsible log groups (for organizing console messages, not displaying data tables), and console.info() just logs the array as text without any tabular visualization or sorting capability. console.table() is specifically designed for inspecting structured data like arrays of objects.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q68",
          "text": "Refer to the following object:\n\nconst dog = {\n  firstName: 'Snoopy',\n  lastName: 'Beagle',\n  get fullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nHow can a developer access the fullName property for dog?",
          "options": [
            {
              "id": "o1",
              "text": "Dog, get,fullName"
            },
            {
              "id": "o2",
              "text": "Dog, function, fullName"
            },
            {
              "id": "o3",
              "text": "Dog.fullName"
            },
            {
              "id": "o4",
              "text": "Dog.fullName ( )"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "The 'get' keyword defines a GETTER, which makes fullName behave like a property rather than a method. Access it as dog.fullName (no parentheses), and JavaScript automatically calls the getter function. The incorrect options: dog.get.fullName is invalid syntax (there's no 'get' property on dog), dog.function.fullName is nonsensical, and dog.fullName() treats it like a method call with parentheses, which will fail because fullName is not a function property - it's a getter that executes when you ACCESS the property, not CALL it. Getters provide computed properties with a clean syntax.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q69",
          "text": "Given the following code: document.body.addEventListener(' click ', (event) => { if (/* CODE REPLACEMENT HERE */) { console.log('button clicked!'); } }); Which replacement for the conditional statement on line 02 allows a developer to correctly determine that a button on page is clicked?",
          "options": [
            {
              "id": "o1",
              "text": "Event.clicked"
            },
            {
              "id": "o2",
              "text": "e.nodeTarget ==this"
            },
            {
              "id": "o3",
              "text": "event.target.nodeName == 'BUTTON'"
            },
            {
              "id": "o4",
              "text": "button.addEventListener('click')"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "When any element inside document.body is clicked, event.target refers to the actual element that was clicked. The event.target.nodeName property returns the tag name in uppercase (e.g., 'BUTTON', 'DIV', 'SPAN'). So checking event.target.nodeName === 'BUTTON' correctly identifies button clicks. The incorrect options: event.clicked doesn't exist as a property, event.nodeTarget is not a valid property (it's event.target), and button.addEventListener('click') is an event registration statement, not a conditional expression. Event delegation pattern: attach one listener to a parent element and use event.target to determine which child was clicked.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q70",
          "text": "Refer to the code below: const addBy = ? const addByEight =addBy(8); const sum = addBYEight(50); Which two functions can replace line 01 and return 58 to sum? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "const addBy = function(num1){ return function(num2){ return num1 + num2; } }"
            },
            {
              "id": "o2",
              "text": "const addBY = (num1) => (num2) => num1 + num2;"
            },
            {
              "id": "o3",
              "text": "const addBy = function(num1){ return num1 + num2; }"
            },
            {
              "id": "o4",
              "text": "const addBy = (num1) => num1 + num2 ;"
            }
          ],
          "correct": [
            "o1",
            "o2"
          ],
          "explanation": "Both correct options create CURRIED FUNCTIONS - functions that return other functions. When addBy(8) is called, it returns a NEW function that remembers num1=8 via closure. Then addByEight(50) calls that returned function with num2=50, computing 8+50=58. The first uses traditional function syntax, the second uses arrow functions with implicit returns. The incorrect options both return single values immediately rather than returning functions: they would make addByEight equal a number (58 or NaN) rather than a callable function, causing addByEight(50) to fail. Currying enables partial application - fixing some arguments now, providing others later.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q71",
          "text": "Refer to the following code: function test (val) { If (val === undefined) { return 'Undefined values!' ; } if (val === null) { return 'Null value! '; } return val; } Let x; test(x); What is returned by the function call on line 13?",
          "options": [
            {
              "id": "o1",
              "text": "'Null value!'"
            },
            {
              "id": "o2",
              "text": "Undefined"
            },
            {
              "id": "o3",
              "text": "Line 13 throws an error."
            },
            {
              "id": "o4",
              "text": "'Undefined values!'"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The variable x is declared with 'let x;' but never assigned a value, so it has the value 'undefined' (not the string, but the actual undefined primitive). When test(x) is called with undefined, the first condition (val === undefined) evaluates to true, and the function returns the STRING 'Undefined values!'. The incorrect options: 'Null value!' would require passing null explicitly, the bare value 'Undefined' would only happen if no return statement executed (but the first condition catches it), and no error is thrown - declaring a variable without initializing it is perfectly valid JavaScript, it just makes the variable undefined.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q72",
          "text": "Cloud Kicks has a class to represent items for sale in an online store, as shown below: Class Item{ constructor (name, price){ this.name = name; this.price = price; } formattedPrice(){ return 's' + String(this.price);}} A new business requirement comes in that requests a ClothingItem class that should have all of the properties and methods of the Item class but will also have properties that are specific to clothes. Which line of code properly declares the clothingItem class such that it inherits from Item?",
          "options": [
            {
              "id": "o1",
              "text": "Class ClothingItem {"
            },
            {
              "id": "o2",
              "text": "Class ClothingItem super Item {"
            },
            {
              "id": "o3",
              "text": "Class ClothingItem extends Item {"
            },
            {
              "id": "o4",
              "text": "Class ClothingItem implements Item{"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "JavaScript class inheritance uses the 'extends' keyword: class ClothingItem extends Item {} creates a subclass that inherits all properties and methods from Item. The incorrect options: plain 'class ClothingItem {}' creates an independent class with no inheritance, 'class ClothingItem super Item {}' has invalid syntax (super is used inside class methods, not in the declaration), and 'class ClothingItem implements Item {}' uses Java/TypeScript interface syntax that doesn't exist in standard JavaScript. The extends keyword establishes the prototype chain, making Item.prototype the prototype of ClothingItem.prototype.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q73",
          "text": "A developer implements a function that adds a few values. Function sum(num) { If (num == undefined) { Num =0; } Return function( num2, num3){ If (num3 ===undefined) { Num3 =0 ; } Return num + num2 + num3; } } Which three options can the developer invoke for this function to get a return value of 10? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "sum(5)(5)"
            },
            {
              "id": "o2",
              "text": "Sum (5, 5) ()"
            },
            {
              "id": "o3",
              "text": "Sum () (20)"
            },
            {
              "id": "o4",
              "text": "sum(10) ()"
            },
            {
              "id": "o5",
              "text": "sum() (5, 5)"
            }
          ],
          "correct": [
            "o1",
            "o5"
          ],
          "explanation": "This curried function has default values: num defaults to 0 if undefined, num3 defaults to 0 if undefined, but num2 has NO default. To get 10: sum(5)(5) means num=5, num2=5, num3=0 (defaulted), so 5+5+0=10. sum()(5,5) means num=0 (defaulted), num2=5, num3=5, so 0+5+5=10. The incorrect options: sum(5,5)() treats the second 5 as ignored (first function only takes one argument), then calls with no arguments causing num2 to be undefined (NaN result). sum()(20) would be 0+20+0=20, and sum(10)() would fail because num2 is undefined (0+undefined+0=NaN). Key: understand which parameters have defaults and currying structure.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q74",
          "text": "Which two console logs outputs NaN? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "console.log(10/ Number('5'));"
            },
            {
              "id": "o2",
              "text": "console.log(10/0);"
            },
            {
              "id": "o3",
              "text": "console.log(10/ 'five');"
            },
            {
              "id": "o4",
              "text": "console.log(parseInt('two'));"
            }
          ],
          "correct": [
            "o3",
            "o4"
          ],
          "explanation": "NaN (Not-a-Number) results from invalid numeric operations. Two cases produce NaN: 10 / 'five' attempts to divide by a string that cannot be coerced to a number ('five' is not numeric), and parseInt('two') tries to parse 'two' which doesn't start with valid digits. The incorrect options: 10 / Number('5') successfully converts '5' to the number 5, returning 2. 10 / 0 returns Infinity (not NaN) - division by zero produces Infinity/-Infinity in JavaScript, not NaN. NaN specifically indicates an operation that should produce a number but cannot (invalid conversions, invalid math).",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q75",
          "text": "Refer to the code below: Let str = 'javascript'; Str[0] = 'J'; Str[4] = 'S'; After changing the string index values, the value of str is 'javascript'. What is the reason for this value?",
          "options": [
            {
              "id": "o1",
              "text": "Primitive values are immutable."
            },
            {
              "id": "o2",
              "text": "Non-primitive values are mutable."
            },
            {
              "id": "o3",
              "text": "Primitive values are mutable."
            },
            {
              "id": "o4",
              "text": "Non-primitive values are immutable."
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Strings in JavaScript are PRIMITIVE values, and all primitive values are IMMUTABLE (cannot be changed). When you try to assign str[0] = 'J', it appears to do nothing - the assignment fails silently (or throws an error in strict mode). To modify a string, you must create a NEW string (e.g., str = 'J' + str.slice(1)). The incorrect options: saying primitives are mutable contradicts JavaScript's core behavior. Non-primitive values (objects, arrays) ARE mutable, but that's not relevant to why string modification failed. The key distinction: primitives (string, number, boolean, null, undefined, symbol, bigint) are immutable; objects are mutable.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q77",
          "text": "Universal Container(UC) just launched a new landing page, but users complain that the website is slow. A developer found some functions that cause this problem. To verify this, the developer decides to do everything and log the time each of these three suspicious functions consumes. console.time('Performance'); maybeAHeavyFunction(); thisCouldTakeTooLong(); orMaybeThisOne(); console.endTime('Performance'); Which function can the developer use to obtain the time spent by every one of the three functions?",
          "options": [
            {
              "id": "o1",
              "text": "console.getTime()"
            },
            {
              "id": "o2",
              "text": "console.trace()"
            },
            {
              "id": "o3",
              "text": "console.timeLog()"
            },
            {
              "id": "o4",
              "text": "console.timeStamp()"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "console.timeLog() outputs the elapsed time for a running timer WITHOUT stopping it, allowing you to log intermediate checkpoints. Insert console.timeLog('Performance') after each function to see cumulative time at each point. The incorrect options: console.getTime() doesn't exist, console.trace() shows the call stack (not timing), and console.timeStamp() (non-standard) adds a marker to browser performance tools but doesn't log elapsed time to the console. Workflow: console.time('label') starts timer, console.timeLog('label') logs checkpoints, console.timeEnd('label') logs final time and stops timer.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q78",
          "text": "Refer to the code snippet: Function getAvailabilityMessage(item) { If (getAvailability(item)){ Var msg =\"Username available\"; } Return msg; } A developer writes this code to return a message to user attempting to register a new username. If the username is available, variable. What is the return value of msg when getAvailabilityMessage (\"newUserName\" ) is executed and getAvailability(\"newUserName\") returns false?",
          "options": [
            {
              "id": "o1",
              "text": "\"Msg is not defined\""
            },
            {
              "id": "o2",
              "text": "\"newUserName\""
            },
            {
              "id": "o3",
              "text": "undefined"
            },
            {
              "id": "o4",
              "text": "\"Username available\""
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Due to 'var' HOISTING, the declaration 'var msg' is moved to the top of the function scope, but the assignment only happens inside the if block. When getAvailability returns false, the if block doesn't execute, so msg is never assigned a value. However, msg still EXISTS in the function scope (hoisted), so when 'return msg' executes, it returns the UNDEFINED value (the default value of uninitialized variables). The incorrect options: 'msg is not defined' would be a ReferenceError if msg wasn't declared at all (but hoisting prevents this), 'newUserName' is the input parameter (not returned), and 'Username available' only happens when the condition is true.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q79",
          "text": "A developer wants to create an object from a function in the browser using the code below: Function Monster() { this.name = 'hello' }; Const z = Monster(); What happens due to lack of the new keyword on line 02?",
          "options": [
            {
              "id": "o1",
              "text": "Window.name is assigned to 'hello' and the variable z remains undefined."
            },
            {
              "id": "o2",
              "text": "Window.m is assigned the correct object."
            },
            {
              "id": "o3",
              "text": "The z variable is assigned the correct object."
            },
            {
              "id": "o4",
              "text": "The z variable is assigned the correct object but this.name remains undefined."
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "When a constructor function is called WITHOUT the 'new' keyword, 'this' refers to the GLOBAL object (window in browsers). So Monster() executes 'this.name = \"hello\"' which becomes 'window.name = \"hello\"', polluting the global scope. The function has no explicit return statement, so it returns undefined, meaning z is assigned undefined. The incorrect options: z does NOT get the correct object (that requires 'new'), window.m doesn't exist (it's window.name, not window.m), and this.name isn't undefined - it successfully assigns to window.name. Always use 'new' with constructor functions to create proper instances.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q80",
          "text": "Refer to the following code:\n\n<html lang=\"en\">\n<body>\n<div onclick=\"console.log('Outer message');\">\n<button id=\"myButton\">CLick me</button>\n</div>\n</body>\n<script>\nfunction displayMessage(ev) {\n  ev.stopPropagation();\n  console.log('Inner message.');\n}\nconst elem = document.getElementById('myButton');\nelem.addEventListener('click', displayMessage);\n</script>\n</html>\n\nWhat will the console show when the button is clicked?",
          "options": [
            {
              "id": "o1",
              "text": "Outer messageInner message"
            },
            {
              "id": "o2",
              "text": "Inner message"
            },
            {
              "id": "o3",
              "text": "Outer message"
            },
            {
              "id": "o4",
              "text": "Inner messageOuter message"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Event bubbling normally propagates from the target element up through ancestors. When the button is clicked, displayMessage executes first (button's listener), logging 'Inner message'. Then ev.stopPropagation() PREVENTS the event from bubbling up to the parent div, so the div's onclick handler never fires. Only 'Inner message' appears. The incorrect options: 'Outer message' alone would require the event to skip the button's handler entirely. 'Outer messageInner message' would mean capturing phase (but this uses bubbling). 'Inner messageOuter message' would occur WITHOUT stopPropagation(), showing normal bubbling behavior.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q81",
          "text": "The developer wants to test the array shown: const arr = Array(5).fill(0) Which two tests are the most accurate for this array? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "arr.forEach(elem => console.assert(elem === 0)) ;"
            },
            {
              "id": "o2",
              "text": "console.assert( arr.length === 5 );"
            },
            {
              "id": "o3",
              "text": "console.assert (arr.length >0);"
            },
            {
              "id": "o4",
              "text": "console.assert(arr[0] === 0 && arr[ arr.length] === 0);"
            }
          ],
          "correct": [
            "o1",
            "o2"
          ],
          "explanation": "Array(5).fill(0) creates an array of length 5 with all elements set to 0: [0, 0, 0, 0, 0]. Two precise tests: arr.forEach(elem => console.assert(elem === 0)) verifies EVERY element equals 0, and console.assert(arr.length === 5) verifies the EXACT length. The incorrect options: console.assert(arr.length > 0) is too weak - it passes for arrays of any non-zero length, not specifically 5. console.assert(arr[0] === 0 && arr[arr.length] === 0) has a bug: arr[arr.length] is arr[5], which is UNDEFINED (arrays are zero-indexed, so valid indices are 0-4). Use arr[arr.length - 1] for the last element.",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q82",
          "text": "Refer to the following code that performs a basic mathematical operation on a provided input: function calculate(num) { Return (num +10) / 3; } How should line 02 be written to ensure that x evaluates to 6 in the line below? Let x = calculate (8);",
          "options": [
            {
              "id": "o1",
              "text": "Return Number((num +10) /3 );"
            },
            {
              "id": "o2",
              "text": "Return Integer(num +10) /3;"
            },
            {
              "id": "o3",
              "text": "Return Number(num + 10) / 3;"
            },
            {
              "id": "o4",
              "text": "Return Math.floor((num +10) / 3);"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The current code (8+10)/3 = 18/3 = 6 already returns 6, so the question must mean a different scenario. Looking at the options: Math.floor((num+10)/3) rounds DOWN to an integer. If the original calculation returned a decimal (like 6.0), Math.floor ensures it's exactly 6 as an integer. The incorrect options: Number((num+10)/3) and Number(num+10)/3 still return the same decimal result as the original. Integer() doesn't exist in JavaScript (not a built-in function). Math.floor is the JavaScript way to ensure an integer result by removing any decimal portion.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q83",
          "text": "A developer has two ways to write a function:\n\nOption A:\nfunction Monster(){\n  this.growl = ()=>{\n    console.log('Grr!');\n  }\n}\n\nOption B:\nfunction Monster(){};\nMonster.prototype.growl = ()=>{\n  console.log('Grr!');\n}\n\nAfter deciding on an option, the developer creates 1000 monster objects. How many growl methods are created with Option A and Option B?",
          "options": [
            {
              "id": "o1",
              "text": "1 methods for both"
            },
            {
              "id": "o2",
              "text": "1000 for both"
            },
            {
              "id": "o3",
              "text": "1000 for Option A, 1 for Option B"
            },
            {
              "id": "o4",
              "text": "1 for Option A, 1000 for Option B"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Option A defines growl INSIDE the constructor, so each time 'new Monster()' runs, it creates a NEW function instance and assigns it to that object's 'this.growl'. Creating 1000 monsters creates 1000 separate growl functions (memory inefficient). Option B defines growl ONCE on Monster.prototype, which all instances share through the prototype chain - 1000 monsters all reference the SAME growl function (memory efficient). The incorrect options reverse the counts or suggest both behave the same. Key principle: methods on the prototype are shared (1 copy), methods on 'this' are per-instance (N copies).",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q84",
          "text": "A developer has an ErrorHandler module that contains multiple functions. What kind of export be leverages so that multiple functions can be used?",
          "options": [
            {
              "id": "o1",
              "text": "Default"
            },
            {
              "id": "o2",
              "text": "Multi"
            },
            {
              "id": "o3",
              "text": "Named"
            },
            {
              "id": "o4",
              "text": "All"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "NAMED exports allow exporting multiple items from a module by name: 'export function handleError() {}', 'export function logError() {}'. Import them with 'import { handleError, logError } from './ErrorHandler''. The incorrect options: DEFAULT export (export default ...) allows only ONE default export per module, suitable for a single main export. 'Multi' and 'All' are not JavaScript module export types. Named exports are the standard way to export multiple functions, classes, or constants from a single module, each with its own identifier.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q85",
          "text": "developer removes the HTML class attribute from the checkout button, so now it is simply: <button>Checkout</button>. There is a test to verify the existence of the checkout button, however it looks for a button with class=\"blue\". The test fails because no such button is found. Which type of test category describes this test?",
          "options": [
            {
              "id": "o1",
              "text": "True positive"
            },
            {
              "id": "o2",
              "text": "False negative"
            },
            {
              "id": "o3",
              "text": "False positive"
            },
            {
              "id": "o4",
              "text": "True negative"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "This is a FALSE NEGATIVE - the test reports a failure when it should pass. The button DOES exist on the page (the functionality is present), but the test fails because it's looking for the wrong selector (class='blue' instead of just finding the button element). The test is too brittle - it's tied to implementation details (CSS class) rather than testing actual functionality. The incorrect options: TRUE POSITIVE means test correctly passes, FALSE POSITIVE means test incorrectly passes when it should fail, TRUE NEGATIVE means test correctly fails. False negatives are problematic because they make developers think something is broken when it actually works.",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q86",
          "text": "A developer has the function, shown below, that is called when a page loads.\n\nfunction onLoad() {\n  console.log('Page has loaded!');\n}\n\nWhere can the developer see the log statement after loading the page in the browser?",
          "options": [
            {
              "id": "o1",
              "text": "On the terminal console running the web server"
            },
            {
              "id": "o2",
              "text": "On the browser JavaScript console"
            },
            {
              "id": "o3",
              "text": "On the webpage console log"
            },
            {
              "id": "o4",
              "text": "In the browser performance tools log"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "console.log() in browser JavaScript outputs to the BROWSER'S JavaScript console (DevTools console), not the server terminal or webpage itself. Access it by pressing F12 or right-click → Inspect → Console tab. The incorrect options: the terminal console running the web server shows server-side logs (Node.js), not client-side JavaScript. There's no 'webpage console log' visible to users - console output is only in DevTools. Browser performance tools track timing metrics, not console.log output. Client-side console.log is a developer tool, invisible to end users.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q87",
          "text": "A developer creates a generic function to log custom messages in the console. To do this, the function below is implemented.\n\n01 function logStatus(status){\n02 console./*Answer goes here*/{'Item status is: %s', status};\n03 }\n\nWhich three console logging methods allow the use of string substitution in line 02?",
          "options": [
            {
              "id": "o1",
              "text": "Log"
            },
            {
              "id": "o2",
              "text": "Info"
            },
            {
              "id": "o3",
              "text": "Message"
            },
            {
              "id": "o4",
              "text": "Assert"
            },
            {
              "id": "o5",
              "text": "Error"
            }
          ],
          "correct": [
            "o1",
            "o2",
            "o5"
          ],
          "explanation": "String substitution with placeholders like %s (string), %d (integer), %f (float) is supported by console.log(), console.info(), and console.error(). These methods replace %s with the provided argument: console.log('Item status is: %s', status) outputs 'Item status is: [status value]'. The incorrect options: console.message() doesn't exist in JavaScript. console.assert() takes a boolean condition first, not a format string with substitution (different syntax). String substitution is a convenient way to format console output without manual concatenation.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q88",
          "text": "A developer has an isDog function that takes one argument cat. They want to schedule the function to run every minute. What is the correct syntax for scheduling this function?",
          "options": [
            {
              "id": "o1",
              "text": "setInterval(isDog, 60000,'cat');"
            },
            {
              "id": "o2",
              "text": "setInterval(isDog('cat'), 60000);"
            },
            {
              "id": "o3",
              "text": "setTimeout(isDog, 60000,'cat');"
            },
            {
              "id": "o4",
              "text": "setInterval(isDog, 1,'cat');"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "setInterval repeats a function at regular intervals (unlike setTimeout which runs once). Syntax: setInterval(functionReference, delay_in_milliseconds, ...args). To run every minute (60000ms) with argument 'cat': setInterval(isDog, 60000, 'cat'). The incorrect options: setInterval(isDog('cat'), 60000) immediately INVOKES isDog and passes its return value (wrong - need function reference). setTimeout runs ONCE, not repeatedly. setInterval(isDog, 1, 'cat') runs every 1 millisecond (not 1 minute). Remember: delay is in milliseconds (1000ms = 1 second, 60000ms = 1 minute).",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q89",
          "text": "At Universal Containers, every team has its own way of copying JavaScript objects. The code snippet shows an implementation from one team:\n\nfunction Person() {\n  this.firstName = 'John';\n  this.lastName = 'Doe';\n  this.name = () => {\n    console.log('Hello ' + this.firstName + ' ' + this.lastName);\n  }\n}\n\nconst john = new Person();\nconst dan = JSON.parse(JSON.stringify(john));\ndan.firstName = 'Dan';\ndan.name();\n\nWhat is the output of the code execution?",
          "options": [
            {
              "id": "o1",
              "text": "Hello Dan Doe"
            },
            {
              "id": "o2",
              "text": "Hello John Doe"
            },
            {
              "id": "o3",
              "text": "TypeError: dan.name is not a function"
            },
            {
              "id": "o4",
              "text": "TypeError: Assignment to constant variable."
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "JSON.stringify() only serializes data properties (primitives, arrays, plain objects), NOT functions/methods. When john is stringified, the name method is OMITTED from the JSON string. JSON.parse() then reconstructs an object with only firstName and lastName - no name property at all. When dan.name() is called, dan.name is undefined, and calling undefined() throws 'TypeError: dan.name is not a function'. The incorrect options: 'Hello Dan Doe' would require the method to exist and work correctly. 'Hello John Doe' would require the method to exist but ignore the firstName change. 'Assignment to constant variable' is unrelated - dan is the constant, but we're modifying its properties (allowed), not reassigning dan itself. Use structuredClone() or Object.assign() to properly copy objects with methods.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q89b",
          "text": "A developer uses the code below to format a date:\n\nconst date = new Date(2020, 05, 10);\nconst dateDisplayOptions = {\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric'\n};\n\nconst formattedDate = date.toLocaleDateString('en', dateDisplayOptions);\n\nAfter executing, what is the value of formattedDate?",
          "options": [
            {
              "id": "o1",
              "text": "May 10, 2020"
            },
            {
              "id": "o2",
              "text": "June 10, 2020"
            },
            {
              "id": "o3",
              "text": "October 05, 2020"
            },
            {
              "id": "o4",
              "text": "November 05, 2020"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "JavaScript Date constructor months are ZERO-INDEXED: 0=January, 1=February, 2=March, 3=April, 4=May, 5=June, 6=July, etc. So new Date(2020, 05, 10) creates JUNE 10, 2020 (not May). This is a common source of bugs - most people expect months to be 1-12, but JavaScript uses 0-11. The toLocaleDateString formats it with 'long' month name: 'June 10, 2020'. The incorrect options: 'May 10, 2020' assumes month 5 = May (wrong indexing), and the October/November options incorrectly swap month and day parameters. Always remember: Date months are 0-indexed, but days and years are not.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q90",
          "text": "Which statement parses successfully?",
          "options": [
            {
              "id": "o1",
              "text": "JSON.parse (\"foo\");"
            },
            {
              "id": "o2",
              "text": "JSON.parse ('\"foo\"');"
            },
            {
              "id": "o3",
              "text": "JSON.parse (\"foo\");"
            },
            {
              "id": "o4",
              "text": "JSON.parse ('\"foo\"');"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "JSON.parse() requires VALID JSON syntax, which mandates DOUBLE QUOTES around strings (not single quotes or bare words). Valid: JSON.parse('\"foo\"') uses single quotes for the JavaScript string literal, and double quotes inside for the JSON string value, successfully parsing to the string 'foo'. The incorrect options: JSON.parse('foo') and JSON.parse(\"foo\") both try to parse the bare word 'foo' which is invalid JSON (only true, false, null are valid bare keywords). Note: The options appear duplicated (o1/o3 and o2/o4 are identical), but the correct answer is the one with properly quoted JSON string.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q91",
          "text": "Universal Containers recently launched its new landing page to host a crowd-funding campaign. The page uses an external library to display some third-party ads. Once the page is fully loaded, it creates more than 50 new HTML items placed randomly inside the DOM, like:\n\n<!-- This is an ad --!>\n<div class=\"ad-library-item ad-hidden\" onLoad=\"myFunction()\">\n\t<img src=\"/ad-library/ad01.gif\" />\n</div>\n\nAll the elements includes the same ad-library-item class. They are hidden by default, and they are randomly displayed while the user navigates through the page.",
          "options": [
            {
              "id": "o1",
              "text": "Use the DOM inspector to remove all the elements containing the class ad-library-item."
            },
            {
              "id": "o2",
              "text": "Use the DOM inspector to prevent the load event to be fired."
            },
            {
              "id": "o3",
              "text": "Use the browser to execute a script that removes all the element containing the class ad-library-item."
            },
            {
              "id": "o4",
              "text": "Use the browser console to execute a script that prevents the load event to be fired."
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "To remove dynamically created ad elements, use the browser console to execute JavaScript: document.querySelectorAll('.ad-library-item').forEach(el => el.remove()). This selects all elements with class 'ad-library-item' and removes them from the DOM. The incorrect options: DOM inspector can manually remove elements one-by-one (tedious for 50+ elements), and preventing the load event won't work since the ads are already loaded and rendered. You can't prevent an event that already fired. A console script provides a programmatic, repeatable solution that removes all matching elements at once.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q92",
          "text": "Which JavaScript methods can be used to serialize an object into a string and deserialize a JSON string into an object, respectively?",
          "options": [
            {
              "id": "o1",
              "text": "JSON.parse and JSON.deserialize"
            },
            {
              "id": "o2",
              "text": "JSON.encode and JSON.decode"
            },
            {
              "id": "o3",
              "text": "JSON.stringify and JSON.parse"
            },
            {
              "id": "o4",
              "text": "JSON.serialize and JSON.deserialize"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "SERIALIZE (object → string): JSON.stringify(obj) converts a JavaScript object into a JSON string. DESERIALIZE (string → object): JSON.parse(str) converts a JSON string back into a JavaScript object. The incorrect options: JSON.serialize/deserialize don't exist in JavaScript. JSON.encode/decode exist in some other languages (like PHP) but not JavaScript. These are the standard JSON methods built into all modern JavaScript environments for data interchange.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q93",
          "text": "A developer is working on an ecommerce website where the delivery date is dynamically calculated based on the current day. The code line below is responsible for this calculation: Const deliveryDate = new Date (); Due to changes in the business requirements, the delivery date must now be today's date + 9 days. Which code meets this new requirement?",
          "options": [
            {
              "id": "o1",
              "text": "deliveryDate.date = Date.current () + 9;"
            },
            {
              "id": "o2",
              "text": "deliveryDate.setDate( Date.current () + 9);"
            },
            {
              "id": "o3",
              "text": "deliveryDate.date = new Date(+9);"
            },
            {
              "id": "o4",
              "text": "deliveryDate.setDate(( new Date ( )).getDate () +9);"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "To add days to a Date object, use setDate(getDate() + days). The correct syntax: deliveryDate.setDate((new Date()).getDate() + 9) gets the current day number with getDate(), adds 9, then sets it with setDate(). JavaScript Date automatically handles month/year rollovers (e.g., if today is Jan 30, adding 9 gives Feb 8). The incorrect options: Date.current() doesn't exist, deliveryDate.date is not a valid property (use getDate/setDate methods), and new Date(+9) creates a date 9 milliseconds after Unix epoch (Jan 1, 1970), not 9 days from today. Note: setDate() can also be simplified to deliveryDate.setDate(deliveryDate.getDate() + 9) since deliveryDate is already initialized.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q94",
          "text": "Given the JavaScript below:\n\nfunction filterDOM(searchString) {\n  const parsedSearchString = searchString && searchString.toLowerCase();\n  document.querySelectorAll('.account').forEach(account => {\n    const accountName = account.innerHTML.toLowerCase();\n    account.style.display = accountName.includes(parsedSearchString) ? /* Insert code here */;\n  });\n}\n\nWhich code should replace the placeholder comment on line 06 to hide accounts that do not match the search string?",
          "options": [
            {
              "id": "o1",
              "text": "'Hidden' : 'visible'"
            },
            {
              "id": "o2",
              "text": "'Visible' : 'hidden'"
            },
            {
              "id": "o3",
              "text": "'None' : 'block'"
            },
            {
              "id": "o4",
              "text": "'Block' : 'none'"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The ternary operator reads: if condition is true, use first value; otherwise use second value. Here: accountName.includes(parsedSearchString) ? 'block' : 'none' means IF the account name matches the search, display: 'block' (show it); IF NOT, display: 'none' (hide it). The incorrect options: 'block' : 'none' has them backwards. 'visible'/'hidden' are CSS visibility values (element still takes up space), not display values. 'Hidden'/'Visible' (capitalized) are invalid CSS values. CSS display: 'none' completely removes the element from layout; display: 'block' makes it visible as a block element.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q95",
          "text": "A developer writes the code below to return a message to a user attempting to register a new username. If the username is available, a variable named msg is declared and assigned a value on line 03.\n\nfunction getAvailabilityMessage(item) {\n  if (getAvailability(item)) {\n    var msg = \"Username available\";\n  }\n  return msg;\n}\n\nWhat is the value of msg when getAvailabilityMessage (\"newUserName\") is executed and getAvailability(\"newUserName\") returns true?",
          "options": [
            {
              "id": "o1",
              "text": "\"Username available\""
            },
            {
              "id": "o2",
              "text": "\"newUserName\""
            },
            {
              "id": "o3",
              "text": "\"msg is not defined\""
            },
            {
              "id": "o4",
              "text": "undefined"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "When getAvailability returns TRUE, the if condition executes, assigning msg = 'Username available'. Due to var hoisting, msg is declared at function scope (not block scope), so it's accessible in the return statement. The function returns 'Username available'. The incorrect options: 'newUserName' is the input parameter (not returned), 'msg is not defined' would only happen with let/const in block scope (but var hoists to function scope), and undefined would only occur if the if block doesn't execute (when getAvailability returns false). This demonstrates how var hoisting makes variables accessible throughout the entire function, regardless of block boundaries.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q96",
          "text": "Refer to the HTML below:\n\n<div id=\"main\">\n  <ul>\n    <li>Leo</li>\n    <li>Tony</li>\n    <li>Tiger</li>\n  </ul>\n</div>\n\nWhich JavaScript statement results in changing \"Tony\" to \"Mr. T.\"?",
          "options": [
            {
              "id": "o1",
              "text": "document.querySelector('#main li:second-child').innerHTML = 'Mr. T.';"
            },
            {
              "id": "o2",
              "text": "document.querySelector('#main li:nth-child(2)').innerHTML = 'Mr. T.';"
            },
            {
              "id": "o3",
              "text": "document.querySelector('#main li.Tony').innerHTML = 'Mr. T.';"
            },
            {
              "id": "o4",
              "text": "document.querySelectorAll('#main #TONY').innerHTML = 'Mr. T.';"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Use the CSS pseudo-class :nth-child(2) to select the second child element: document.querySelector('#main li:nth-child(2)') targets the second <li> (Tony). The incorrect options: :second-child is NOT a valid CSS selector (no such pseudo-class exists). li.Tony looks for an <li> with class='Tony', but the HTML has no class attribute. querySelectorAll('#main #TONY') looks for an element with id='TONY', but none exists (and querySelectorAll returns a NodeList, which doesn't have innerHTML directly). CSS nth-child is 1-indexed: nth-child(1) = first, nth-child(2) = second, etc.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q97",
          "text": "A developer wrote the following code:\n\n01 let x = object.value;\n02\n03 try {\n04   handleObjectValue(x);\n05 } catch (error) {\n06   handleError(error);\n07 }\n\nThe developer has a getNextValue function to execute after handleObjectValue(), but does not want to execute getNextValue() if an error occurs. How can the developer change the code to ensure this behavior?",
          "options": [
            {
              "id": "o1",
              "text": "03 try { 04 handleObjectValue(x); 05 getNextValue(); 06 } catch(error) { 07 handleError(error); 08 }"
            },
            {
              "id": "o2",
              "text": "03 try{ 04 handleObjectValue(x); 05 } catch(error){ 06 handleError(error); 07 } 08 getNextValue();"
            },
            {
              "id": "o3",
              "text": "03 try{ 04 handleObjectValue(x); 05 }catch(error){ 06 handleError(error); 07 } then { 08 getNextValue(); 09 }"
            },
            {
              "id": "o4",
              "text": "03 try{ 04 handleObjectValue(x); 05 } catch(error){ 06 handleError(error); 07 } finally { 08 getNextValue(); 10 }"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Place getNextValue() INSIDE the try block after handleObjectValue(). If handleObjectValue() throws an error, execution jumps immediately to the catch block, SKIPPING getNextValue(). If no error occurs, getNextValue() executes normally. The incorrect options: placing getNextValue() AFTER the try-catch (outside) makes it execute regardless of errors. There's no 'then' syntax for try-catch (that's for promises). The finally block ALWAYS executes whether an error occurs or not, so getNextValue() would run even after errors. Try-catch flow: try executes line-by-line until error or completion; catch only runs if error occurs; finally always runs.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q98",
          "text": "A developer creates a new web server that uses Node.js. It imports a server library that uses events and callbacks for handling server functionality. The server library is imported with require and is made available to the code by a variable named server. The developer wants to log any issues that the server has while booting up. Given the code and the information the developer has, which code logs an error at boot with an event?",
          "options": [
            {
              "id": "o1",
              "text": "Try{ server.start(); } catch(error) { console.log('ERROR', error); }"
            },
            {
              "id": "o2",
              "text": "Server.catch ((server) => { console.log('ERROR', error); });"
            },
            {
              "id": "o3",
              "text": "Server.on ('error', (error) => { console.log('ERROR', error); });"
            },
            {
              "id": "o4",
              "text": "Server.error ((server) => { console.log('ERROR', error); });"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Node.js EventEmitter pattern uses .on(eventName, callback) to register event listeners. For error events: server.on('error', (error) => { console.log('ERROR', error); }) listens for 'error' events emitted by the server and executes the callback when they occur. The incorrect options: try-catch doesn't work with asynchronous event-based APIs (errors happen outside the try block's scope). server.catch() is for promises, not EventEmitters. server.error() doesn't exist as a method. Event-driven architecture: objects emit events, listeners react to them using .on() or .addEventListener().",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q99",
          "text": "Consider type coercion, what does the following expression evaluate to? True + 3 + '100' + null",
          "options": [
            {
              "id": "o1",
              "text": "4100"
            },
            {
              "id": "o2",
              "text": "'3100null'"
            },
            {
              "id": "o3",
              "text": "104"
            },
            {
              "id": "o4",
              "text": "'4100null'"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Type coercion step-by-step: (1) true converts to number 1, (2) 1 + 3 = 4 (numeric addition), (3) 4 + '100' = '4100' (string concatenation - when one operand is a string, + concatenates), (4) '4100' + null = '4100null' (null converts to string 'null'). Final result: '4100null'. The incorrect options: 4100 (numeric) would require all numeric addition with no strings. '3100null' incorrectly treats true as 0 or skips it. 104 would require interpreting '100' as numeric and somehow getting to 104. Type coercion rules: boolean→number (true=1, false=0), string + anything = string concatenation, null→'null' when concatenating.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q100",
          "text": "A developer needs to test this function:\n\nconst sum3 = (arr) => {\n  if (!arr.length) return 0;\n  if (arr.length === 1) return arr[0];\n  if (arr.length === 2) return arr[0]+ arr[1];\n  return arr[0] + arr[1] + arr[2];\n};\n\nWhich two assert statements are valid tests for the function? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "console.assert(sum3(0)) == 0);"
            },
            {
              "id": "o2",
              "text": "console.assert(sum3([1, '2']) == 12);"
            },
            {
              "id": "o3",
              "text": "console.assert(sum3([-3, 2]) == -1);"
            },
            {
              "id": "o4",
              "text": "console.assert(sum3(['hello', 2, 3, 4]) === NaN);"
            }
          ],
          "correct": [
            "o2",
            "o3"
          ],
          "explanation": "Testing sum3 with edge cases: sum3([1, '2']) performs 1 + '2' = '12' (string concatenation), and '12' == 12 is TRUE due to type coercion (== converts '12' to 12). sum3([-3, 2]) returns -3 + 2 = -1 (correct numeric addition). The incorrect options: sum3(0) passes a NUMBER not an ARRAY, causing arr.length to throw TypeError (0 has no length property). sum3(['hello', 2, 3, 4]) returns 'hello' + 2 + 3 = 'hello23' (string), but NaN === NaN is ALWAYS false in JavaScript (NaN is not equal to itself), so this assertion would always fail even if it returned NaN.",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q101",
          "text": "Given the following code: Let x =('15' + 10)*2; What is the value of x?",
          "options": [
            {
              "id": "o1",
              "text": "50"
            },
            {
              "id": "o2",
              "text": "1520"
            },
            {
              "id": "o3",
              "text": "3020"
            },
            {
              "id": "o4",
              "text": "35"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Operator precedence and type coercion: (1) Parentheses first: '15' + 10 = '1510' (string concatenation), (2) Then multiplication: '1510' * 2 coerces '1510' to number 1510, then 1510 * 2 = 3020. The incorrect options: 50 would require numeric addition throughout ((15 + 10) * 2). 1520 would result from '15' + 10 + 2 or '15' + (10 * 2) without parentheses. 35 doesn't match any valid interpretation. Key insight: + with strings concatenates, but * ALWAYS attempts numeric coercion (no string multiplication in JavaScript).",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q102",
          "text": "Refer to code below:\n\nLet first = 'who';\nLet second = 'what';\nTry{\n  Try{\n    Throw new Error('Sad trombone');\n  } catch (err) {\n    First ='Why';\n  } finally {\n    Second ='when';\n  }\n} catch (err) {\n  Second ='Where';\n}\n\nWhat are the values for first and second once the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "First is why and second is when"
            },
            {
              "id": "o2",
              "text": "First is Who and second is When"
            },
            {
              "id": "o3",
              "text": "First is who and second is where"
            },
            {
              "id": "o4",
              "text": "First is why and second is where"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Execution flow: (1) Inner try throws error, (2) Inner catch executes, setting first = 'Why' (note: variable names are case-sensitive, so 'First' in code should be 'first'), (3) Finally ALWAYS executes, setting second = 'when', (4) Outer catch does NOT execute because the error was already caught by the inner catch. Final values: first = 'why' (assuming case-sensitive assignment), second = 'when'. The incorrect options assume various failures of the try-catch-finally flow. Key concept: finally blocks execute regardless of whether an error occurs or is caught, and a caught error doesn't propagate to outer catch blocks.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q103",
          "text": "The developer wants to test this code:\n\nConst toNumber =(strOrNum) => strOrNum;\n\nWhich two tests are most accurate for this code? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "console.assert(toNumber('2') === 2);"
            },
            {
              "id": "o2",
              "text": "console.assert(Number.isNaN(toNumber()));"
            },
            {
              "id": "o3",
              "text": "console.assert(toNumber () === NaN);"
            },
            {
              "id": "o4",
              "text": "console.assert(toNumber('-3') < 0);"
            }
          ],
          "correct": [
            "o1",
            "o4"
          ],
          "explanation": "The function just returns its input unchanged: const toNumber = (strOrNum) => strOrNum. Testing what the function ACTUALLY does (not what it should do): toNumber('2') === 2 is FALSE (returns '2', not 2 - the function doesn't convert). toNumber('-3') < 0 is TRUE (JavaScript coerces '-3' to -3 for comparison, and -3 < 0). The incorrect options: Number.isNaN(toNumber()) is TRUE (calling with no argument returns undefined, but we're testing the function's behavior). toNumber() === NaN is always FALSE (NaN !== NaN). The correct tests validate actual behavior: one tests string input, another tests comparison coercion.",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q104",
          "text": "Refer to HTML below:\n\n<div id=\"main\">\n  <div id=\"card-00\">This card is smaller.</div>\n  <div id=\"card-01\">The width and height of this card is determined by its contents.</div>\n</div>\n\nWhich expression outputs the screen width of the element with the ID card-01?",
          "options": [
            {
              "id": "o1",
              "text": "document.getElementById('card-01').style.width"
            },
            {
              "id": "o2",
              "text": "document.getElementById('card-01').getBoundingClientRect().width"
            },
            {
              "id": "o3",
              "text": "document.getElementById('card-01').innerHTML.length*8"
            },
            {
              "id": "o4",
              "text": "document.getElementById('card-01').width"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "getBoundingClientRect().width returns the ACTUAL RENDERED width of an element in pixels, including content, padding, and border (the visual width on screen). The incorrect options: element.style.width only returns inline styles set via JavaScript or style attribute (returns empty string if width is set via CSS or computed), and doesn't give the actual rendered width. element.width doesn't exist as a property (only for specific elements like img, canvas). innerHTML.length * 8 is a naive calculation that doesn't account for font size, wrapping, or actual layout. Use getBoundingClientRect() for accurate, computed dimensions.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q105",
          "text": "Given the following code: Let x =null; console.log(typeof x); What is the output of line 02?",
          "options": [
            {
              "id": "o1",
              "text": "\"Null\""
            },
            {
              "id": "o2",
              "text": "\"undefined\""
            },
            {
              "id": "o3",
              "text": "\"X\""
            },
            {
              "id": "o4",
              "text": "\"Object\""
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "typeof null returns 'object' - this is a famous JavaScript bug from the language's original implementation that has been kept for backward compatibility. typeof should logically return 'null', but it returns 'object' instead. The incorrect options: 'Null' and 'undefined' are not returned (typeof always returns lowercase strings like 'object', 'string', 'number', 'boolean', 'function', 'undefined', 'symbol', 'bigint'). 'X' is not a valid typeof return value. This quirk is important to remember when checking for null - use x === null instead of typeof x === 'object'.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q106",
          "text": "Refer to the following code:\n\nfunction Tiger() {\n  this.type = 'cat';\n  this.size = 'large';\n}\n\nlet tony = new Tiger();\ntony.roar = () => {\n  console.log('They\\'re great!');\n};\n\nfunction Lion() {\n  this.type = 'cat';\n  this.size = 'large';\n}\n\nlet leo = new Lion();\n// Insert code here\nleo.roar();\n\nWhich two statements could be inserted at line 17 to enable the function call on line 18? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "Object.assign (leo, tony);"
            },
            {
              "id": "o2",
              "text": "leo.roar = () => { console.log('They\\'re pretty good!'); };"
            },
            {
              "id": "o3",
              "text": "leo.prototype.roar = () => { console.log('They\\'re pretty good!'); };"
            },
            {
              "id": "o4",
              "text": "Object.assign (leo, Tiger);"
            }
          ],
          "correct": [
            "o1",
            "o2"
          ],
          "explanation": "Two ways to add the roar method to leo: Object.assign(leo, tony) copies all enumerable own properties from tony (including the roar method) to leo. Directly assigning leo.roar = () => { console.log(...); } adds the method to leo. The incorrect options: leo.prototype.roar doesn't work because leo is an INSTANCE, not a constructor - instances don't have a meaningful prototype property for adding methods. Object.assign(leo, Tiger) copies from the Tiger CONSTRUCTOR FUNCTION (which has no roar method), not from tony (which has roar as an instance property). Use Object.assign to copy properties between objects, or direct assignment to add new properties.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q107",
          "text": "Which option is true about the strict mode in imported modules?",
          "options": [
            {
              "id": "o1",
              "text": "Add the statement use strict =false; before any other statements in the module to enable not-strict mode."
            },
            {
              "id": "o2",
              "text": "Add the statement use non-strict; before any other statements in the module to enable not-strict mode."
            },
            {
              "id": "o3",
              "text": "You can only reference notStrict() functions from the imported module."
            },
            {
              "id": "o4",
              "text": "Imported modules are in strict mode whether you declare them as such or not."
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "ES6 modules (files using import/export) are ALWAYS in strict mode automatically - you cannot disable it. Strict mode is built into the module specification and applies whether you explicitly write 'use strict' or not. The incorrect options: 'use strict = false' is invalid syntax (use strict is a directive, not a variable assignment). 'use non-strict' doesn't exist. There's no concept of 'notStrict() functions' - all code in a module runs in strict mode. This ensures consistent, safer behavior across all module code (prevents common mistakes like undeclared variables, duplicate parameters, etc.).",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q108",
          "text": "Given the HTML below:\n\n<div>\n  <div id=\"row-wc\">Universal Containers</div>\n  <div id=\"row-as\">Applied Shipping</div>\n  <div id=\"row-bt\">Burlington Textiles</div>\n</div>\n\nWhich statement adds the priority-account CSS class to the Applied Shipping row?",
          "options": [
            {
              "id": "o1",
              "text": "document.querySelector('#row-as').classList.add('priority-account');"
            },
            {
              "id": "o2",
              "text": "document.querySelector('#row-as').class.add('priority-account');"
            },
            {
              "id": "o3",
              "text": "document.getElementById('row-as').className += ' priority-account';"
            },
            {
              "id": "o4",
              "text": "document.getElementById('row-as').addClass('priority-account');"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Use element.classList.add('className') to add a CSS class - this is the modern, clean approach that handles duplicates automatically. The incorrect options: element.class doesn't exist (it's classList). element.className += ' priority-account' WORKS but is less elegant - it's string concatenation and requires the leading space to avoid merging class names. element.addClass() doesn't exist in vanilla JavaScript (it's a jQuery method). classList provides add(), remove(), toggle(), contains() methods for managing classes cleanly.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q109",
          "text": "Refer to the following code:\n\n<html lang=\"en\">\n  <body>\n    <span onclick=\"console.log('Span message');\">\n      <button id=\"myButton\">Send Message</button>\n    </span>\n  </body>\n  <script>\n    function displayMessage(ev){\n      ev.stopPropagation();\n      console.log('Button message');\n    }\n    const elem = document.getElementById(\"myButton\");\n    elem.addEventListener('click',displayMessage);\n  </script>\n</html>\n\nWhat will the console show when the button is clicked?",
          "options": [
            {
              "id": "o1",
              "text": "Button message"
            },
            {
              "id": "o2",
              "text": "Outer message"
            },
            {
              "id": "o3",
              "text": "Outer message<br>Inner message"
            },
            {
              "id": "o4",
              "text": "Inner message<br>Outer message"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "When the button is clicked, displayMessage executes and logs 'Button message'. Then ev.stopPropagation() prevents the event from bubbling up to the parent span, so the span's onclick handler never fires. Only 'Button message' appears. The incorrect options: 'Outer message' would be from the span, but that's prevented by stopPropagation(). The combinations would occur if bubbling wasn't stopped. Note: the question mentions 'Span message' in the HTML but uses 'Outer message' in options - this inconsistency aside, stopPropagation blocks parent handlers from executing.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q110",
          "text": "Refer to the code below:\n\nlet total = 10;\nconst interval = setInterval(() => {\n  total++;\n  clearInterval(interval);\n  total++;\n}, 0);\ntotal++;\nconsole.log(total);\n\nConsidering that JavaScript is single-threaded, what is the output of line 08 after the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "11"
            },
            {
              "id": "o2",
              "text": "13"
            },
            {
              "id": "o3",
              "text": "12"
            },
            {
              "id": "o4",
              "text": "10"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "JavaScript event loop: synchronous code executes first, then asynchronous callbacks. Execution: (1) total = 10, (2) setInterval is SCHEDULED (callback goes to task queue), (3) total++ executes immediately (total = 11), (4) console.log(total) executes immediately, logging 11, (5) LATER, the callback runs (total becomes 12, then 13, but console.log already executed). Even though setInterval delay is 0ms, the callback still waits for the current synchronous code to finish. The console.log runs BEFORE the callback, outputting 11.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q111",
          "text": "A test has a dependency on database.query. During the test, the dependency is replaced with an object called database with the method Calculator query, that returns an array. The developer does not need to verify how many times the method has been called. Which two test approaches describe the requirement? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "White box"
            },
            {
              "id": "o2",
              "text": "Stubbing"
            },
            {
              "id": "o3",
              "text": "Black box"
            },
            {
              "id": "o4",
              "text": "Substitution"
            }
          ],
          "correct": [
            "o1",
            "o4"
          ],
          "explanation": "This describes STUBBING (or mocking): replacing a real dependency (database.query) with a fake object that returns predetermined values, without verifying call counts. WHITE BOX testing examines internal implementation (knowing about the database.query dependency indicates white box). The incorrect options: BLACK BOX testing only examines inputs/outputs without internal knowledge. SUBSTITUTION is not a standard testing term (though test doubles/stubs are about substitution). The key distinction: STUB = fake with predetermined responses (no call tracking), MOCK = fake that verifies interactions (call counts, parameters).",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q112",
          "text": "A developer wrote a fizzbuzz function that when passed in a number, returns the following:\n\n'Fizz' if the number is divisible by 3.\n'Buzz' if the number is divisible by 5.\n'Fizzbuzz' if the number is divisible by both 3 and 5.\nEmpty string if the number is divisible by neither 3 or 5.\n\nWhich two test cases will properly test scenarios for the fizzbuzz function? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "let res = fizzbuzz(5); console.assert ( res === '' );"
            },
            {
              "id": "o2",
              "text": "let res = fizzbuzz(3); console.assert ( res === 'fizz' );"
            },
            {
              "id": "o3",
              "text": "let res = fizzbuzz(15); console.assert ( res === 'fizzbuzz' );"
            },
            {
              "id": "o4",
              "text": "let res = fizzbuzz(Infinity); console.assert ( res === '' );"
            }
          ],
          "correct": [
            "o2",
            "o3",
            "o4"
          ],
          "explanation": "Testing fizzbuzz rules: fizzbuzz(3) should return 'Fizz' (divisible by 3, case-sensitive check shows 'fizz' vs 'Fizz' mismatch). fizzbuzz(15) should return 'Fizzbuzz' (divisible by both, case matches). fizzbuzz(Infinity) should return '' (Infinity % 3 and Infinity % 5 are both NaN, which is falsy, so not divisible by either). The incorrect option: fizzbuzz(5) should return 'Buzz' (divisible by 5), NOT empty string. Note: The question shows inconsistent casing ('Fizz' vs 'fizz'), but the valid tests are those that match expected behavior for their inputs.",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q113",
          "text": "Given the JavaScript below:\n\n01 function filterDOM (searchString) {\n02   const parsedSearchString = searchString && searchString.toLowerCase();\n03   document.querySelectorAll('.account').forEach(account => {\n04     const accountName = account.innerHTML.toLowerCase();\n05     account.style.display = accountName.includes(parsedSearchString) ? /* Insert code here */;\n06   });\n07 }\n\nWhich code should replace the placeholder comment on line 05 to hide accounts that do not match the search string?",
          "options": [
            {
              "id": "o1",
              "text": "'name' : 'block'"
            },
            {
              "id": "o2",
              "text": "'hidden' : 'visible'"
            },
            {
              "id": "o3",
              "text": "'visible' : 'hidden'"
            },
            {
              "id": "o4",
              "text": "'block' : 'none'"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Ternary operator: condition ? valueIfTrue : valueIfFalse. If accountName.includes(parsedSearchString) is TRUE (match found), set display: 'block' (show). If FALSE (no match), set display: 'none' (hide). The incorrect options: 'name' is not a valid display value. 'hidden'/'visible' are CSS visibility property values (element still occupies space), not display values. 'visible' is not a valid display value at all. CSS display: 'none' removes element from layout completely; 'block' makes it visible as a block-level element.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q114",
          "text": "Refer to the code below:\n\nConst resolveAfterMilliseconds = (ms) => Promise.resolve(\n  setTimeout (() => console.log(ms), ms));\nConst aPromise = await resolveAfterMilliseconds(500);\nConst bPromise = await resolveAfterMilliseconds(500);\nAwait aPromise, wait bPromise;\n\nWhat is the result of running line 05?",
          "options": [
            {
              "id": "o1",
              "text": "aPromise and bPromise run sequentially."
            },
            {
              "id": "o2",
              "text": "Neither aPromise or bPromise runs."
            },
            {
              "id": "o3",
              "text": "Only aPromise runs."
            },
            {
              "id": "o4",
              "text": "aPromise and bPromise run in parallel."
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "Line 5 'Await aPromise, wait bPromise;' has a SYNTAX ERROR - 'wait' is not a keyword (should be 'await'). This throws a SyntaxError before any code runs. Additionally, the code has logical issues: Promise.resolve(setTimeout(...)) resolves immediately with a timeout ID (a number), not with a promise that waits. The await on lines 3-4 gets the timeout ID immediately, not the result after delay. So aPromise and bPromise are numbers, not promises. Even if syntax were fixed, nothing would 'run' at line 5 because awaiting numbers just returns them. The fundamental issue: NEITHER promise properly delays, AND line 5 has a syntax error.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q116",
          "text": "Refer to the code below? Let searchString = ' look for this '; Which two options remove the whitespace from the beginning of searchString? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "trimStart(searchString);"
            },
            {
              "id": "o2",
              "text": "searchString.trimEnd();"
            },
            {
              "id": "o3",
              "text": "searchString.replace(/^\\s\\s*/, '');"
            },
            {
              "id": "o4",
              "text": "searchString.trimStart();"
            }
          ],
          "correct": [
            "o3",
            "o4"
          ],
          "explanation": "Two ways to remove leading whitespace: searchString.trimStart() is a built-in method that removes whitespace from the START of a string. searchString.replace(/^\\s\\s*/, '') uses regex: ^ = start of string, \\s\\s* = one or more whitespace characters, replacing them with empty string. The incorrect options: trimStart(searchString) has wrong syntax - trimStart is a STRING METHOD, not a standalone function (need searchString.trimStart()). searchString.trimEnd() removes TRAILING whitespace (end of string), not leading. Note: trimStart() is also aliased as trimLeft().",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q117",
          "text": "Refer to the code below:\n\nfunction execute() {\n  return new Promise((resolve, reject) => reject());\n}\nlet promise = execute();\n\npromise\n  .then(() => console.log('Resolved1'))\n  .then(() => console.log('Resolved2'))\n  .then(() => console.log('Resolved3'))\n  .catch(() => console.log('Rejected'))\n  .then(() => console.log('Resolved4'));\n\nWhat is the result when the Promise in the execute function is rejected?",
          "options": [
            {
              "id": "o1",
              "text": "Rejected1 Rejected2 Rejected3 Rejected Rejected Rejected4"
            },
            {
              "id": "o2",
              "text": "Resolved1 Resolved2 Resolved3Resolved4"
            },
            {
              "id": "o3",
              "text": "Rejected"
            },
            {
              "id": "o4",
              "text": "Rejected Resolved4"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Promise chain flow when rejected: the promise rejects, execution SKIPS all .then() handlers (Resolved1, Resolved2, Resolved3 never log) and jumps to the FIRST .catch(), which logs 'Rejected'. After .catch() handles the rejection, the chain is RESTORED to resolved state, so the NEXT .then() executes, logging 'Resolved4'. Output: 'Rejected' then 'Resolved4'. The incorrect options: the three 'Resolved' handlers before .catch() are skipped entirely. The .catch() handles the rejection and allows subsequent .then() to run. Key concept: .catch() catches rejection and returns a resolved promise (unless it re-throws).",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q118",
          "text": "Refer to the expression below: Let x = ('1' + 2) == (6 * 2); How should this expression be modified to ensure that evaluates to false?",
          "options": [
            {
              "id": "o1",
              "text": "Let x = (1 + 2) == ( '6' / 2);"
            },
            {
              "id": "o2",
              "text": "Let x = (1+ 2 ) == ( 6 / 2);"
            },
            {
              "id": "o3",
              "text": "Let x = ('1' + 2) === ( 6 * 2);"
            },
            {
              "id": "o4",
              "text": "Let x = ('1' + ' 2') == ( 6 * 2);"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Original: ('1' + 2) == (6 * 2) evaluates '12' == 12, which is TRUE (== allows type coercion, converting '12' to 12). To make it FALSE, use === (strict equality): ('1' + 2) === (6 * 2) evaluates '12' === 12, which is FALSE (different types: string vs number, no coercion). The incorrect options: (1 + 2) == ('6' / 2) evaluates 3 == 3, TRUE. (1 + 2) == (6 / 2) evaluates 3 == 3, TRUE. ('1' + ' 2') == (6 * 2) evaluates '1 2' == 12, FALSE due to space, but not the intended solution. Use === to prevent type coercion and ensure type-safe comparisons.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q119",
          "text": "A developer is asked to fix some bugs reported by users. To do that, the developer adds a breakpoint for debugging.\n\nFunction Car (maxSpeed, color){\n  This.maxspeed = maxSpeed;\n  This.color = color;\n}\nLet carSpeed = document.getElementById('CarSpeed');\nDebugger;\nLet fourWheels = new Car (carSpeed.value, 'red');\n\nWhen the code execution stops at the breakpoint on line 06, which two types of information are available in the browser console? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "The values of the carSpeed and fourWheels variables"
            },
            {
              "id": "o2",
              "text": "The style, event listeners and other attributes applied to the carSpeed DOM element"
            },
            {
              "id": "o3",
              "text": "The information stored in the window.localStorage property"
            },
            {
              "id": "o4",
              "text": "A variable displaying the number of instances created for the Car Object."
            }
          ],
          "correct": [
            "o2",
            "o3"
          ],
          "explanation": "When debugger pauses at line 06 (before 'let fourWheels = ...'): carSpeed variable EXISTS (can inspect DOM element's style, event listeners, attributes via console). window.localStorage is ALWAYS accessible (global browser API). The incorrect options: fourWheels does NOT exist yet (breakpoint is BEFORE its declaration on line 07). JavaScript doesn't automatically track instance counts - you'd need custom code. At the breakpoint, you can inspect existing variables (carSpeed), DOM properties, and global APIs (localStorage), but not variables declared after the breakpoint.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q120",
          "text": "Refer to the code below:\n\nconst event = new CustomEvent(\n  //Missing Code\n);\nobj.dispatchEvent(event);\n\nA developer needs to dispatch a custom event called update to send information about recordId. Which two options could a developer insert at the placeholder in line 02 to achieve this? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "'Update' , '123abc'"
            },
            {
              "id": "o2",
              "text": "'Update' , {recordId : '123abc'}"
            },
            {
              "id": "o3",
              "text": "{ type : 'update', recordId : '123abc' }"
            },
            {
              "id": "o4",
              "text": "'Update' , {detail : {recordId : '123abc'}}"
            }
          ],
          "correct": [
            "o2",
            "o4"
          ],
          "explanation": "CustomEvent constructor syntax: new CustomEvent(eventName, {detail: customData}). The event name must be a STRING. Two valid forms: ('update', {recordId: '123abc'}) works but is non-standard (recordId won't be in event.detail), and ('update', {detail: {recordId: '123abc'}}) is the CORRECT way (data accessible via event.detail.recordId). The incorrect options: {type: 'update', recordId: '123abc'} is invalid - first argument must be a STRING, not an object. ('update', '123abc') passes a string as options, which doesn't create proper event data. Always use the detail property for custom event data.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q121",
          "text": "Refer to the code below:\n\nlet country = {\n  get capital() {\n    let city = Number(\"London\");\n    return {\n      cityString: city.toString(),\n    }\n  }\n}\n\nWhich value can a developer expect when referencing country.capital.cityString?",
          "options": [
            {
              "id": "o1",
              "text": "'London'"
            },
            {
              "id": "o2",
              "text": "An error"
            },
            {
              "id": "o3",
              "text": "'NaN'"
            },
            {
              "id": "o4",
              "text": "undefined"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Number('London') attempts to convert the string 'London' to a number, which fails and returns NaN (Not-a-Number). Then city.toString() converts NaN to the STRING 'NaN'. So country.capital.cityString returns the string 'NaN' (not the value NaN, not undefined, not an error). The incorrect options: 'London' would require the string to survive conversion (it doesn't). An error would require invalid operations (Number() and toString() are both valid). undefined would mean the property doesn't exist (but it does, with value 'NaN'). Number() coerces strings to numbers, returning NaN for non-numeric strings.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q122",
          "text": "A developer receives a comment from the Tech Lead that the code given below has error:\n\nconst monthName = 'July';\nconst year = 2019;\nif(year === 2019) {\n  monthName ='June';\n}\n\nWhich line edit should be made to make this code run?",
          "options": [
            {
              "id": "o1",
              "text": "01 let monthName ='July';"
            },
            {
              "id": "o2",
              "text": "02 let year =2019;"
            },
            {
              "id": "o3",
              "text": "02 const year = 2020;"
            },
            {
              "id": "o4",
              "text": "03 if (year == 2019) {"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Line 04 tries to reassign monthName with 'monthName = 'June'', but line 01 declares monthName with CONST, which prevents reassignment. Attempting to reassign throws TypeError: Assignment to constant variable. Fix: change line 01 to 'let monthName = 'July'' to allow reassignment. The incorrect options: changing year to let doesn't fix the monthName reassignment error. Changing year to 2020 doesn't address the const issue. Changing === to == doesn't fix the const error (both operators work here). Use const for values that won't change, let for values that will be reassigned.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q123",
          "text": "Given two expressions var1 and var2. What are two valid ways to return the logical AND of the two expressions and ensure it is data type Boolean? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "var1.toBoolean() && var2.toBoolean()"
            },
            {
              "id": "o2",
              "text": "Boolean(var1 && var2)"
            },
            {
              "id": "o3",
              "text": "Boolean(var1) && Boolean(var2)"
            },
            {
              "id": "o4",
              "text": "var1 && var2"
            }
          ],
          "correct": [
            "o2",
            "o3"
          ],
          "explanation": "To ensure BOOLEAN type: Boolean(var1 && var2) performs logical AND first (which may return a truthy/falsy value, not necessarily true/false), then converts to boolean. Boolean(var1) && Boolean(var2) converts EACH value to boolean first, then performs AND, guaranteeing boolean result. The incorrect options: var1 && var2 returns one of the operands (truthy or falsy value), NOT necessarily a boolean (e.g., 5 && 3 returns 3, not true). toBoolean() doesn't exist as a method in JavaScript. The && operator with booleans guarantees boolean output, but with non-booleans it may return non-boolean values.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q124",
          "text": "Universal Containers (UC) just launched a new landing page, but users complain that the website is slow. A developer found some functions that might cause this problem. To verify this, the developer decides to execute everything and log the time each of these three suspicious functions consumes.\n\nconsole.time('Performance');\nmaybeAHeavyFunction();\nthisCouldTakeTooLong();\norMaybeThisOne();\nconsole.endTime('Performance');\n\nWhich function can the developer use to obtain the time spent by every one of the three functions?",
          "options": [
            {
              "id": "o1",
              "text": "console.timeLog()"
            },
            {
              "id": "o2",
              "text": "console.getTime()"
            },
            {
              "id": "o3",
              "text": "console.trace()"
            },
            {
              "id": "o4",
              "text": "console.timeStamp()"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "Insert console.timeLog('Performance') after EACH function to log cumulative elapsed time at that checkpoint: console.time('Performance'); maybeAHeavyFunction(); console.timeLog('Performance'); // logs time after 1st function, thisCouldTakeTooLong(); console.timeLog('Performance'); // logs time after 2nd function, orMaybeThisOne(); console.timeEnd('Performance'); // logs final time and stops. This shows how much time has elapsed at each checkpoint, allowing you to see which function(s) consumed the most time. The incorrect options: console.getTime() doesn't exist, console.trace() shows call stack (not timing), console.timeStamp() is non-standard and doesn't log to console.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q125",
          "text": "There is a new requirement for a developer to implement a currPrice method that will return the current price of the item on sales.\n\nlet saleItem = {\n  name: 'item',\n  price: 50,\n  discount: 10,\n  get currPrice() {\n    return this.price - (this.price * this.discount);\n  }\n};\n\nconsole.log(saleItem.currPrice);\nconsole.log(saleItem.price);\nconsole.log(saleItem.discount);\nconsole.log(saleItem.currPrice);\n\nWhat is the output when executing the code above?",
          "options": [
            {
              "id": "o1",
              "text": "50Uncaught TypeError: saleItem.description is not a function5080"
            },
            {
              "id": "o2",
              "text": "5080Uncaught ReferenceError:this.discount is undefined72"
            },
            {
              "id": "o3",
              "text": "50805072"
            },
            {
              "id": "o4",
              "text": "508072"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "The currPrice getter calculates: this.price - (this.price * this.discount) = 50 - (50 * 10) = 50 - 500 = -450. Output sequence: currPrice returns -450, price is 50, discount is 10, currPrice again returns -450. So the output would be -450, 50, 10, -450 (but the options show different values). Looking at option values: if discount was meant to be 0.1 (10%), then 50 - (50 * 0.1) = 50 - 5 = 45. But as written, discount=10 gives -450. The question appears to have an error in the expected output, but based on the provided options, the code runs without errors and outputs four values.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q126",
          "text": "Refer to the string below: Const str = 'salesforce'; Which two statements result in the word 'sales'? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "str.substring(1,5);"
            },
            {
              "id": "o2",
              "text": "str.substr(0,5);"
            },
            {
              "id": "o3",
              "text": "str.substr(1,5);"
            },
            {
              "id": "o4",
              "text": "str.substring(0,5);"
            }
          ],
          "correct": [
            "o2",
            "o4"
          ],
          "explanation": "substring(start, end) extracts from start index up to (but NOT including) end index: str.substring(0, 5) gets characters 0-4 = 'sales'. substr(start, length) extracts from start index for specified LENGTH: str.substr(0, 5) starts at 0 and takes 5 characters = 'sales'. The incorrect options: str.substring(1, 5) gets characters 1-4 = 'ales' (skips 's'). str.substr(1, 5) starts at index 1 and takes 5 characters = 'alesf'. Note: substr() is deprecated (use substring() or slice() instead). substring vs slice: substring doesn't support negative indices, slice does.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q127",
          "text": "A developer is wondering whether to use Promise.then or Promise.catch, especially when a Promise throws an error? Which two promises are rejected? Which 2 are correct?",
          "options": [
            {
              "id": "o1",
              "text": "Promise.reject('cool error here').catch(error => console.error(error));"
            },
            {
              "id": "o2",
              "text": "Promise.reject('cool error here').then(error => console.error(error));"
            },
            {
              "id": "o3",
              "text": "New Promise((resolve, reject) => {throw 'cool error here'}).catch(error =>console.error(error));"
            },
            {
              "id": "o4",
              "text": "New Promise(() => {throw 'cool error here'}).then(null, error => console.error(error)));"
            }
          ],
          "correct": [
            "o1",
            "o3"
          ],
          "explanation": "Promises are rejected when: Promise.reject('error') explicitly creates a rejected promise, and throwing inside a Promise executor (new Promise((resolve, reject) => { throw 'error' })) also causes rejection. Both correctly use .catch() to handle rejections. The incorrect options: Promise.reject().then() is wrong - .then() handles SUCCESS, not rejection (though .then(null, errorHandler) can handle rejection as second argument). new Promise(() => { throw 'error' }).then(null, errorHandler) is valid syntax but less common - .catch() is clearer. Use .catch() for error handling, .then() for success handling.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q128",
          "text": "Refer to the code below: Let textValue = '1984'; Which code assignment shows a correct way to convert this string to an integer?",
          "options": [
            {
              "id": "o1",
              "text": "Let numberValue = (Number)textValue;"
            },
            {
              "id": "o2",
              "text": "Let numberValue = Integer(textValue);"
            },
            {
              "id": "o3",
              "text": "Let numberValue = textValue.toInteger();"
            },
            {
              "id": "o4",
              "text": "let numberValue = Number(textValue);"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Number(textValue) converts the string '1984' to the number 1984. The incorrect options: (Number)textValue uses invalid cast syntax (JavaScript doesn't have type casting like C/Java). Integer(textValue) - Integer() doesn't exist in JavaScript (use Number() or parseInt()). textValue.toInteger() - strings don't have a toInteger() method. Alternative valid conversions: parseInt(textValue, 10), parseFloat(textValue), +textValue, or textValue * 1. Number() is the most explicit and readable approach.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q129",
          "text": "Refer to code below:\n\nLet productSKU = '8675309';\n\nA developer has a requirement to generate SKU numbers that are always 19 characters long, starting with 'sku', and padded with zeros. Which statement assigns the value sku0000000008675309?",
          "options": [
            {
              "id": "o1",
              "text": "productSKU = productSKU.padStart(19, '0').padstart('sku');"
            },
            {
              "id": "o2",
              "text": "productSKU = productSKU.padEnd(16, '0').padstart('sku');"
            },
            {
              "id": "o3",
              "text": "productSKU = productSKU.padEnd(16, '0').padstart(19, 'sku');"
            },
            {
              "id": "o4",
              "text": "productSKU = productSKU.padStart(16, '0').padstart(19, 'sku');"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Working backwards from target 'sku0000000008675309' (19 chars): Start with '8675309' (7 chars). First padStart(16, '0') adds zeros to the LEFT until length is 16: '0000000008675309'. Then padStart(19, 'sku') adds 'sku' to the LEFT until length is 19: 'sku0000000008675309'. The incorrect options: padEnd() adds to the RIGHT (wrong direction). padStart without the second call won't add 'sku'. Incorrect lengths or order fail. Note: padStart(targetLength, padString) repeats padString as needed until the string reaches targetLength.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q130",
          "text": "Which function should a developer use to repeatedly execute code at a fixed interval?",
          "options": [
            {
              "id": "o1",
              "text": "setinterval"
            },
            {
              "id": "o2",
              "text": "setTimeout"
            },
            {
              "id": "o3",
              "text": "setPeriod"
            },
            {
              "id": "o4",
              "text": "setInteria"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "setInterval(callback, delay) repeatedly executes the callback function at fixed intervals (every delay milliseconds) until clearInterval is called. setTimeout(callback, delay) executes ONCE after the delay. The incorrect options: setPeriod() and setInteria() don't exist in JavaScript. Example: setInterval(() => console.log('tick'), 1000) logs 'tick' every second. Use clearInterval(intervalId) to stop the repeated execution. setInterval is for repeated actions; setTimeout is for delayed single actions.",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q131",
          "text": "Refer to the following array:\n\nLet arr = [1, 2, 3, 4, 5];\n\nWhich three options result in x evaluating as [3, 4, 5]? Choose 3 answers.",
          "options": [
            {
              "id": "o1",
              "text": "Let x = arr.filter((a) => (a < 2));"
            },
            {
              "id": "o2",
              "text": "Let x = arr.splice(2, 3);"
            },
            {
              "id": "o3",
              "text": "Let x = arr.slice(2);"
            },
            {
              "id": "o4",
              "text": "Let x = arr.filter((a) => (return a > 2));"
            },
            {
              "id": "o5",
              "text": "Let x = arr.slice(2, 3);"
            }
          ],
          "correct": [
            "o2",
            "o3",
            "o4"
          ],
          "explanation": "Three ways to get [3, 4, 5]: arr.splice(2, 3) REMOVES and RETURNS 3 elements starting at index 2 (mutates original array). arr.slice(2) COPIES elements from index 2 to end (non-mutating). arr.filter((a) => (return a > 2)) is INVALID SYNTAX - arrow functions with implicit return don't use 'return' keyword. Should be arr.filter(a => a > 2). The incorrect options: arr.filter(a => a < 2) returns [1] (less than 2). arr.slice(2, 3) returns [3] only (from index 2 up to but not including 3). The question has an error: option 4 with 'return' keyword in arrow function is invalid syntax.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q132",
          "text": "Refer to the code:\n\nfunction Animal(size, type) {\n  this.size = size || 'small';\n  this.type = type || 'Animal';\n  this.canTalk = false;\n}\n\nlet Pet = function(size, type, name, owner) {\n  Animal.call(this, size, type);\n  this.name = name;\n  this.owner = owner;\n};\n\nPet.prototype = Object.create(Animal.prototype);\nlet pet1 = new Pet();\nconsole.log(pet1);\n\nGiven the code above, which three properties are set on pet1? Choose 3 answers:",
          "options": [
            {
              "id": "o1",
              "text": "name"
            },
            {
              "id": "o2",
              "text": "canTalk"
            },
            {
              "id": "o3",
              "text": "type"
            },
            {
              "id": "o4",
              "text": "owner"
            },
            {
              "id": "o5",
              "text": "size"
            }
          ],
          "correct": [
            "o2",
            "o3",
            "o5"
          ],
          "explanation": "When new Pet() is called with NO arguments, Animal.call(this, size, type) is called with size=undefined, type=undefined. The Animal constructor uses defaults: this.size = undefined || 'small' = 'small', this.type = undefined || 'Animal' = 'Animal', this.canTalk = false. Then Pet constructor tries this.name = name (undefined), this.owner = owner (undefined). Properties set on pet1: size='small', type='Animal', canTalk=false. Properties NOT truly set (remain undefined, not own properties): name, owner. JavaScript doesn't create properties with undefined values unless explicitly assigned. So pet1 has three own properties: size, type, canTalk.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q133",
          "text": "Refer to the code below:\n\n01 const exec = (item, delay) => {\n02   new Promise(resolve => setTimeout(() => resolve(item), delay)),\n03   async function runParallel() {\n04     const (result1, result2, result3) = await Promise.all{\n05       [exec('x', '100'), exec('y', 500), exec('z', '100')]\n06     );\n07     return `parallel is done: $(result1) $(result2)$(result3)`;\n08   }\n09 }\n\nWhich two statements correctly execute the runParallel() function? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "Async runParallel().then(data);"
            },
            {
              "id": "o2",
              "text": "runParallel().done(function(data){\nreturn data;\n});"
            },
            {
              "id": "o3",
              "text": "runParallel().then(data);"
            },
            {
              "id": "o4",
              "text": "runParallel().then(function(data)\nreturn data"
            }
          ],
          "correct": [
            "o2",
            "o4"
          ],
          "explanation": "Async functions return Promises. The code has syntax errors (missing return, wrong Promise.all syntax), but assuming runParallel() returns a promise: .then(callback) is the standard way - callback receives resolved value. The incorrect options: 'async runParallel()' has invalid syntax ('async' is for function DECLARATIONS, not calls). runParallel().done() doesn't exist in native Promise API (it's from older libraries like jQuery). 'runParallel().then(data)' without a callback function is invalid - .then() requires a function. The question has errors, but valid syntax: runParallel().then(function(data) { return data; }).",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q134",
          "text": "Which three statements are true about promises? Choose 3 answers",
          "options": [
            {
              "id": "o1",
              "text": "The executor of a new Promise runs automatically."
            },
            {
              "id": "o2",
              "text": "A Promise has a .then() method."
            },
            {
              "id": "o3",
              "text": "A fulfilled or rejected promise will not change states."
            },
            {
              "id": "o4",
              "text": "A settled promise can become resolved."
            },
            {
              "id": "o5",
              "text": "A pending promise can become fulfilled, settled, or rejected."
            }
          ],
          "correct": [
            "o2",
            "o3",
            "o5"
          ],
          "explanation": "Three true statements: Promises have a .then() method for chaining and handling resolved values. Once a Promise reaches fulfilled or rejected state, it CANNOT change (immutable state). A pending Promise can become fulfilled OR rejected (both are 'settled' states - settled is not a third state but a term describing non-pending). The incorrect options: The executor runs immediately when 'new Promise()' is called, not 'automatically' in some delayed way (but option 1 might be considered true). A settled (fulfilled or rejected) Promise CANNOT become resolved again - it's already settled. Key: Promises have three states: pending → fulfilled, pending → rejected (final states).",
          "category": [
            "Asynchronous Programming"
          ]
        },
        {
          "id": "q135",
          "text": "Given the code below:\n\n01 function GameConsole(name) {\n02   this.name = name;\n03 }\n04\n05 GameConsole.prototype.load = function(gamename) {\n06   console.log(`$(this.name) is loading a game: $(gamename)...`);\n07 }\n08 function Console16Bit(name) {\n09   GameConsole.call(this, name);\n10 }\n11 Console16bit.prototype = Object.create(GameConsole.prototype);\n12 //insert code here\n13 console.log(`$(this.name) is loading a cartridge game: $(gamename)...`);\n14 }\n15 const console16bit = new Console16bit('SNEGeneziz');\n16 console16bit.load('Super Nonic 3x Force');\n\nWhat should a developer insert at line 12 to output the following message using the method?\n> SNEGeneziz is loading a cartridge game: Super Monic 3x Force...",
          "options": [
            {
              "id": "o1",
              "text": "Console16bit.prototype.load(gamename) = function() {"
            },
            {
              "id": "o2",
              "text": "Console16bit.prototype.load = function(gamename) {"
            },
            {
              "id": "o3",
              "text": "Console16bit = Object.create(GameConsole.prototype).load = function\n(gamename) {"
            },
            {
              "id": "o4",
              "text": "Console16bit.prototype.load(gamename) {"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "To OVERRIDE the inherited load method from GameConsole, define a new load method on Console16bit's prototype: Console16bit.prototype.load = function(gamename) { ... }. This replaces the inherited method with a specialized version. The incorrect options: Console16bit.prototype.load(gamename) = function() has invalid syntax (trying to call then assign). Console16bit = Object.create(...).load = ... overwrites the Console16bit constructor entirely (destructive). Console16bit.prototype.load(gamename) { lacks the = function syntax. Prototype method override pattern: ChildClass.prototype.methodName = function(...) { custom implementation }.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q136",
          "text": "A developer publishes a new version of a package with new features that do not break backward compatibility. The previous version number was 1.1.3. Following semantic versioning format, what should the new package version number be?",
          "options": [
            {
              "id": "o1",
              "text": "2.0.0"
            },
            {
              "id": "o2",
              "text": "1.2.3"
            },
            {
              "id": "o3",
              "text": "1.1.4"
            },
            {
              "id": "o4",
              "text": "1.2.0"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "Semantic versioning format: MAJOR.MINOR.PATCH. MAJOR (1.x.x → 2.0.0): breaking changes that break backward compatibility. MINOR (1.1.x → 1.2.0): new features that ARE backward compatible. PATCH (1.1.3 → 1.1.4): bug fixes only, no new features. Since the new version adds features WITHOUT breaking compatibility, increment MINOR and reset PATCH: 1.1.3 → 1.2.0. The incorrect options: 2.0.0 signals breaking changes. 1.1.4 is for bug fixes only. 1.2.3 incorrectly keeps the old PATCH number. Always reset PATCH to 0 when incrementing MINOR.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q137",
          "text": "A developer wants to define a function log to be used a few times on a single-file JavaScript script.\n\n01 // Line 1 replacement\n02 console.log('LOG:', logInput);\n03 }\n\nWhich two options can correctly replace line 01 and declare the function for use? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "function log(logInput) {"
            },
            {
              "id": "o2",
              "text": "const log(loginInput) {"
            },
            {
              "id": "o3",
              "text": "const log = (logInput) => {"
            },
            {
              "id": "o4",
              "text": "function log = (logInput) {"
            }
          ],
          "correct": [
            "o1",
            "o3"
          ],
          "explanation": "Two valid function declaration syntaxes: function log(logInput) { ... } is a FUNCTION DECLARATION (hoisted, can be called before declaration). const log = (logInput) => { ... } is an ARROW FUNCTION EXPRESSION (not hoisted, must be declared before use). The incorrect options: const log(logInput) { is invalid syntax (missing = and =>). function log = (logInput) { mixes function declaration and expression syntax incorrectly. For simple utility functions in scripts, both function declarations and arrow function expressions work well, with different hoisting behaviors.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q138",
          "text": "A developer is setting up a new Node.js server with a client library that is built using events and callbacks. The library will establish a web socket connection and handle receipt of messages to the server. It will be imported with require, and made available with a variable called ws. The developer also wants to add error logging if a connection fails. Given this info, which code segment shows the correct way to set up a client with two events that listen at execution time?",
          "options": [
            {
              "id": "o1",
              "text": "ws.connect(() => {console.log('connected to client');}).catch((error) => {console.log('ERROR', error);});"
            },
            {
              "id": "o2",
              "text": "ws.on('connect', () => {console.log('connected to client'); ws.on('error', (error) => {console.log('ERROR', error);});});"
            },
            {
              "id": "o3",
              "text": "ws.on('connect', () => {console.log('connected to client');}); ws.on('error', (error) => {console.log('ERROR', error);});"
            },
            {
              "id": "o4",
              "text": "try{ws.connect(() => {console.log('connected to client');});} catch(error) {console.log('ERROR', error);};}"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "Node.js EventEmitter pattern: use .on(eventName, callback) to register event listeners. Correct approach: ws.on('connect', callback1); ws.on('error', callback2); registers BOTH listeners at the TOP LEVEL, active from execution time. The incorrect options: ws.connect().catch() uses Promise syntax (not event-based). Nesting ws.on('error') inside ws.on('connect') means the error listener only registers AFTER connection succeeds (won't catch connection errors). try-catch doesn't work with asynchronous event-based APIs. Event listeners must be registered BEFORE events can occur, so register both listeners immediately.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q139",
          "text": "The developer has a function that prints 'Hello' to an input name. To test this, the developer created a function that returns 'World'. However the following snippet does not print 'Hello World'.\n\nconst sayHello = (name) => {\n  console.log('Hello', name());\n};\n\nconst world = () => {\n  return 'World';\n};\n\nsayHello(world);\n\nWhat can the developer do to change the code to print 'Hello World'?",
          "options": [
            {
              "id": "o1",
              "text": "Change line 2 to console.log('Hello', name());"
            },
            {
              "id": "o2",
              "text": "Change line 5 to function world() {"
            },
            {
              "id": "o3",
              "text": "Change line 7 to )();"
            },
            {
              "id": "o4",
              "text": "Change line 9 to sayHello(world)();"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The code ALREADY WORKS correctly - line 2 has console.log('Hello', name()) which CALLS the name function. When sayHello(world) is called, name parameter receives the world function reference, then name() executes it, returning 'World'. The output IS 'Hello World'. The question states the code doesn't work, but it actually does. The incorrect options: changing to function world() doesn't affect behavior. Adding )(); or ()() creates invalid syntax. This appears to be a trick question - the code is already correct as written, and option 1 suggests the same code that's already there.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q140",
          "text": "A developer copied a JavaScript object:\n\nlet obj = {\n  firstName: 'John',\n  lastName: 'Doe',\n  name: function() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nlet dan = Object.create(obj);\ndan.firstName = 'Dan';\ndan.lastName = 'Smith';\n\nHow does the developer access dan's firstName and lastName? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "dan.name"
            },
            {
              "id": "o2",
              "text": "dan.firstname() + dan.lastName()"
            },
            {
              "id": "o3",
              "text": "dan.name()"
            },
            {
              "id": "o4",
              "text": "dan.firstName + dan.lastName"
            }
          ],
          "correct": [
            "o3",
            "o4"
          ],
          "explanation": "Two ways to access the combined name: dan.name() calls the INHERITED method from obj (via prototype chain), which returns this.firstName + ' ' + this.lastName = 'Dan Smith' (with space). dan.firstName + dan.lastName directly accesses the OWN properties on dan, concatenating 'Dan' + 'Smith' = 'DanSmith' (no space). The incorrect options: dan.name without parentheses returns the function object itself, not the result. dan.firstName() + dan.lastName() tries to CALL properties as functions, throwing TypeError (firstName and lastName are strings, not functions). Properties are accessed with dot notation; methods are called with parentheses.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q141",
          "text": "Which statement can a developer apply to increment the browser's navigation history without a page refresh?",
          "options": [
            {
              "id": "o1",
              "text": "window.history.pushState(newStateObject, '', null);"
            },
            {
              "id": "o2",
              "text": "window.history.pushState(newStateObject);"
            },
            {
              "id": "o3",
              "text": "window.history.replaceState(newStateObject, '', null);"
            },
            {
              "id": "o4",
              "text": "window.history.state.push(newStateObject);"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The correct answer is window.history.pushState(newStateObject, '', null) because it properly adds a NEW entry to the browser's history stack without causing a page refresh, using all three required parameters: state object, title (empty string), and URL (null keeps current URL). The incorrect options: window.history.pushState(newStateObject) is missing required parameters (title and url). window.history.replaceState(newStateObject, '', null) REPLACES the current history entry instead of adding a new one (doesn't increment history length). window.history.state.push(newStateObject) is invalid syntax - history.state is a property, not an array with a push method. Key concept: pushState() adds to history for navigation; replaceState() modifies current entry.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q142",
          "text": "Which three actions can be done using the JavaScript browser console? Choose 3 answers:",
          "options": [
            {
              "id": "o1",
              "text": "View and change the DOM of the page."
            },
            {
              "id": "o2",
              "text": "Run code that is not related to the page."
            },
            {
              "id": "o3",
              "text": "View and change security cookies."
            },
            {
              "id": "o4",
              "text": "Display a report showing the performance of a page."
            },
            {
              "id": "o5",
              "text": "View, change, and debug the JavaScript code of the page."
            }
          ],
          "correct": [
            "o1",
            "o2",
            "o5"
          ],
          "explanation": "The correct actions are: (1) View and change the DOM using document methods and DevTools Elements panel integration. (2) Run any JavaScript code, even unrelated to the page context. (3) View, change, and debug the page's JavaScript through DevTools debugger, breakpoints, and console commands. The incorrect options: 'View and change security cookies' is FALSE - HttpOnly and Secure cookies cannot be accessed/modified via console for security reasons (only document.cookie for accessible cookies). 'Display performance report' is FALSE - performance reports require the separate Performance/Profiler tab, not the console. Key concept: Console is for execution and debugging, not specialized reports or secure data access.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q143",
          "text": "A developer is trying to convince management that their team will benefit from using Node.js for a backend server that they are going to create. The server will be a web server that handles API requests from a website that the team has already built using HTML, CSS, and JavaScript. Which three benefits of Node.js can the developer use to persuade their manager? Choose 3 answers:",
          "options": [
            {
              "id": "o1",
              "text": "Performs a static analysis on code before execution to look for runtime errors."
            },
            {
              "id": "o2",
              "text": "Ensures stability with one major release every few years."
            },
            {
              "id": "o3",
              "text": "Installs with its own package manager to install and manage third-party libraries."
            },
            {
              "id": "o4",
              "text": "Uses non-blocking functionality for performant request handling."
            },
            {
              "id": "o5",
              "text": "Executes server-side JavaScript code to avoid learning a new language."
            }
          ],
          "correct": [
            "o3",
            "o4",
            "o5"
          ],
          "explanation": "The three correct benefits are: (1) 'Installs with npm package manager' - Node.js includes npm for easy dependency management and access to the world's largest package ecosystem. (2) 'Non-blocking functionality' - Node.js uses asynchronous I/O for handling many concurrent requests efficiently without blocking threads (ideal for API servers). (3) 'Server-side JavaScript' - The team already knows JavaScript from frontend work, so no new language learning required (code reuse, shared validation logic, unified stack). The incorrect options: 'Static analysis before execution' is FALSE - Node.js doesn't perform automatic static analysis (requires separate tools like ESLint/TypeScript). 'One major release every few years' is FALSE - Node.js has frequent releases with new major versions roughly every 6 months (active development, not stability-focused long cycles). Key concept: Node.js excels at async I/O, developer productivity (one language), and ecosystem (npm).",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q144",
          "text": "Refer to the string below:\n\nconst str = 'salesforce';\n\nWhich two statements result in the word 'Sales'? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "str.substr(1,5);"
            },
            {
              "id": "o2",
              "text": "str.substring(0,5);"
            },
            {
              "id": "o3",
              "text": "str.substr(0,5);"
            },
            {
              "id": "o4",
              "text": "str.substring(1,5);"
            }
          ],
          "correct": [
            "o2",
            "o3"
          ],
          "explanation": "The two correct answers are: str.substring(0,5) extracts characters from index 0 up to (but not including) index 5 = 'sales' (5 characters). str.substr(0,5) starts at index 0 and extracts 5 characters = 'sales'. Both return 'sales' (lowercase). The incorrect options: str.substr(1,5) starts at index 1 (skips 's') and takes 5 characters = 'alesf' (not 'sales'). str.substring(1,5) extracts from index 1 to 5 = 'ales' (only 4 characters, missing 's'). Note: The question asks for 'Sales' (capitalized) but 'salesforce' is all lowercase, so the correct methods return 'sales' not 'Sales' - this appears to be a question error. Key concept: substring(start, end) uses indices; substr(start, length) uses start + count (substr is deprecated).",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q145",
          "text": "Refer to the following code block:\n\nclass Student {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  takeTest() {\n    console.log(`${this.name} got 70% on test.`);\n  }\n}\n\nclass BetterStudent extends Student {\n  constructor(name) {\n    super(name);\n    this.name = 'Better student ' + name;\n  }\n  \n  takeTest() {\n    console.log(`${this.name} got 100% on test.`);\n  }\n}\n\nlet student = new BetterStudent('Jackie');\nstudent.takeTest();\n\nWhat is the console output?",
          "options": [
            {
              "id": "o1",
              "text": "> Better student Jackie got 100% on test."
            },
            {
              "id": "o2",
              "text": "> Uncaught Reference Error"
            },
            {
              "id": "o3",
              "text": "> Better student Jackie got 70% on test."
            },
            {
              "id": "o4",
              "text": "> Jackie got 70% on test."
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The correct output is 'Better student Jackie got 100% on test.' because: BetterStudent extends Student and OVERRIDES both constructor and takeTest() method. The constructor calls super(name) first, then modifies this.name to 'Better student ' + name = 'Better student Jackie'. When student.takeTest() is called, JavaScript uses BetterStudent's overridden version (not Student's), which logs the modified name with '100%'. The incorrect options: 'Uncaught Reference Error' is wrong - no reference errors occur (super and this are properly used). 'Better student Jackie got 70% on test' is wrong - BetterStudent's takeTest() shows 100%, not 70% from parent class. 'Jackie got 70% on test' is wrong - the name was modified to 'Better student Jackie' and the method was overridden to show 100%. Key concept: Method override means child class method REPLACES parent's method completely.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q146",
          "text": "Refer to code below:\n\nlet a = 'a';\nlet b;\n// b = a;\nconsole.log(b);\n\nWhat is displayed when the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "null"
            },
            {
              "id": "o2",
              "text": "ReferenceError: b is not defined"
            },
            {
              "id": "o3",
              "text": "a"
            },
            {
              "id": "o4",
              "text": "undefined"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The correct output is 'undefined' because variable b is DECLARED with 'let b;' but never INITIALIZED with a value (the line 'b = a;' is commented out with //). In JavaScript, declared but uninitialized variables automatically have the value 'undefined'. The incorrect options: 'null' is wrong - null must be explicitly assigned; it's not the default value for uninitialized variables. 'ReferenceError: b is not defined' is wrong - b IS defined/declared with 'let b;', so no ReferenceError (would only occur if b wasn't declared at all). 'a' is wrong - the assignment b = a is commented out, so b never receives the value from a. Key concept: Declared but uninitialized variables = undefined; undeclared variables = ReferenceError; null is explicit assignment.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q147",
          "text": "A developer has code that calculates a restaurant bill, but generates incorrect answers while testing the code:\n\nfunction calculateBill(items) {\n  let total = 0;\n  total += findSubTotal(items);\n  total += addTax(total);\n  total += addTip(total);\n  return total;\n}\n\nWhich option allows the developer to step into each function execution within calculateBill?",
          "options": [
            {
              "id": "o1",
              "text": "Using the debugger command on line 03"
            },
            {
              "id": "o2",
              "text": "Using the debugger command on line 05."
            },
            {
              "id": "o3",
              "text": "Calling the console.trace(total) method on line 03."
            },
            {
              "id": "o4",
              "text": "Wrapping findSubtotal in a console.log() method."
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The correct answer is 'debugger on line 05' because placing the debugger statement BEFORE the function calls (total += findSubTotal(items);) pauses execution at that point, allowing the developer to use DevTools' 'Step Into' feature to enter each function (findSubTotal, addTax, addTip) and inspect their execution. The incorrect options: 'debugger on line 03' would pause too late - line 03 is INSIDE the total calculations, missing the opportunity to step into findSubTotal from the beginning. 'console.trace(total) on line 03' only logs the call stack, it doesn't pause execution or allow stepping through function calls. 'Wrapping findSubtotal in console.log()' only logs the return value, it doesn't enable step-by-step debugging into the function's internal logic. Key concept: debugger statement pauses execution; Step Into (F11) allows entering function calls; placement matters for catching the right moment.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q148",
          "text": "Given the following code:\n\nlet x = null;\nconsole.log(typeof x);\n\nWhat is the output of line 02?",
          "options": [
            {
              "id": "o1",
              "text": "\"object\""
            },
            {
              "id": "o2",
              "text": "\"x\""
            },
            {
              "id": "o3",
              "text": "\"null\""
            },
            {
              "id": "o4",
              "text": "\"undefined\""
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The correct output is 'object' because typeof null returns 'object' - this is a famous JavaScript quirk/bug from the language's original implementation that has been kept for backward compatibility. Despite null being a primitive value representing intentional absence of value, typeof incorrectly reports it as 'object'. The incorrect options: 'x' is wrong - typeof returns the TYPE of the value, not the variable name. 'null' is wrong - typeof returns a STRING describing the type, not the value itself (and null's type is incorrectly reported as 'object', not 'null'). 'undefined' is wrong - undefined is what typeof returns for undefined values (let x; without assignment), but null is explicitly set and returns 'object'. Key concept: typeof null === 'object' is a known bug; to check for null, use x === null instead of typeof.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q149",
          "text": "Refer to the code below:\n\nlet foodMenu1 = ['pizza', 'burger', 'French fries'];\nlet finalMenu = foodMenu1;\nfinalMenu.push('Garlic bread');\n\nWhat is the value of foodMenu1 after the code executes?",
          "options": [
            {
              "id": "o1",
              "text": "['pizza', 'burger', 'French fries', 'Garlic bread']"
            },
            {
              "id": "o2",
              "text": "['pizza', 'burger', 'French fries']"
            },
            {
              "id": "o3",
              "text": "['Garlic bread', 'pizza', 'burger', 'French fries']"
            },
            {
              "id": "o4",
              "text": "['Garlic bread']"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The correct value is ['pizza', 'burger', 'French fries', 'Garlic bread'] because arrays are REFERENCE TYPES (not primitive values). The assignment finalMenu = foodMenu1 creates a reference pointing to the SAME ARRAY in memory, not a copy. When finalMenu.push('Garlic bread') executes, it modifies the original array that both variables reference. Both foodMenu1 and finalMenu point to the same modified array. The incorrect options: ['pizza', 'burger', 'French fries'] would only be correct if arrays were copied by value or if we used spread operator [...foodMenu1] or .slice() to create a copy. ['Garlic bread', 'pizza', 'burger', 'French fries'] is wrong - push() adds to the END, not the beginning (unshift() adds to beginning). ['Garlic bread'] is wrong - push() adds to existing array, doesn't replace it. Key concept: Arrays/objects are passed by reference; use [...array] or array.slice() to create independent copies.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q150",
          "text": "After user acceptance testing, the developer is asked to change the webpage background based on user's location. This change was implemented and deployed for testing. The tester reports that the background is not changing, however it works as required when viewing on the developer's computer. Which two actions will help determine accurate results? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "The tester should disable their browser cache."
            },
            {
              "id": "o2",
              "text": "The developer should rework the code."
            },
            {
              "id": "o3",
              "text": "The developer should inspect their browser refresh settings."
            },
            {
              "id": "o4",
              "text": "The tester should clear their browser cache."
            }
          ],
          "correct": [
            "o3",
            "o4"
          ],
          "explanation": "The two correct actions are: (1) 'Developer should inspect browser refresh settings' to verify cache-busting is configured properly (e.g., cache headers, versioned assets, hard refresh behavior). (2) 'Tester should clear their browser cache' to remove old cached CSS/JS files and force downloading the new code with location-based background changes. The incorrect options: 'Tester should disable browser cache' is not the best solution - disabling cache entirely is extreme and affects performance; clearing cache once is sufficient. 'Developer should rework the code' is premature - if it works on developer's machine, the code logic is likely fine; the issue is deployment/caching, not code correctness. Key concept: 'Works on my machine' bugs are often caching issues; verify with hard refresh (Ctrl+Shift+R), check cache headers (Cache-Control), and ensure deployment succeeded.",
          "category": [
            "Debugging and Error Handling"
          ]
        },
        {
          "id": "q151",
          "text": "Refer to code below:\n\nfunction myFunction(reassign) {\n  let x = 1;\n  var y = 1;\n  if(reassign) {\n    let x = 2;\n    var y = 2;\n    console.log(x);\n    console.log(y);\n  }\n  console.log(x);\n  console.log(y);\n}\n\nWhat is displayed when myFunction(true) is called?",
          "options": [
            {
              "id": "o1",
              "text": "2 2 2 2"
            },
            {
              "id": "o2",
              "text": "2 2 1 2"
            },
            {
              "id": "o3",
              "text": "2 2 undefined undefined"
            },
            {
              "id": "o4",
              "text": "2 2 1 1"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The correct output is '2 2 1 2' because of let vs var scoping differences: let is BLOCK-SCOPED - 'let x = 2' inside the if block creates a NEW variable separate from outer 'let x = 1'. var is FUNCTION-SCOPED - 'var y = 2' inside the if block REASSIGNS the same function-level y variable. Line-by-line execution: console.log(x) inside if block prints 2 (block-scoped x). console.log(y) inside if block prints 2 (reassigned function-scoped y). console.log(x) after if block prints 1 (outer x unchanged - block x is out of scope). console.log(y) after if block prints 2 (function-scoped y was reassigned). The incorrect options: '2 2 2 2' would occur if both were var (both reassigned). '2 2 undefined undefined' would occur if neither were declared (ReferenceError, not undefined). '2 2 1 1' would occur if both were let (both block-scoped, outer unchanged). Key concept: let = block scope; var = function scope; same name doesn't mean same variable with let.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q152",
          "text": "A developer is debugging a web server that uses Node.js. The server hits a runtime error every third request to an important endpoint on the web server. The developer added a breakpoint to the start script, that is at index.js at the root of the server's source code. The developer wants to make use of Chrome DevTools to debug. Which command can be run to access DevTools and make sure the breakpoint is hit?",
          "options": [
            {
              "id": "o1",
              "text": "node inspect index.js"
            },
            {
              "id": "o2",
              "text": "node -i index.js"
            },
            {
              "id": "o3",
              "text": "node --inspect index.js"
            },
            {
              "id": "o4",
              "text": "node --inspect-brk index.js"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "The correct command is 'node --inspect index.js' because the --inspect flag starts Node.js with the Chrome DevTools inspector agent enabled, allowing connection via chrome://inspect. The server runs normally and breakpoints set in the code will be hit when requests arrive. The incorrect options: 'node inspect index.js' launches the LEGACY command-line debugger (text-based, not Chrome DevTools). 'node -i index.js' starts an interactive REPL mode after running the script, not debugging mode. 'node --inspect-brk index.js' is close but BREAKS IMMEDIATELY before any code runs, which is too early if the developer wants to reproduce the issue by making requests (--inspect-brk is for debugging startup issues). Key concept: --inspect enables Chrome DevTools remote debugging; --inspect-brk adds immediate breakpoint at start; use chrome://inspect to connect.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q153",
          "text": "Refer to the following code block:\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  makeSound() {\n    console.log(`${this.name} is making a sound.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name);\n    this.name = name;\n  }\n  makeSound() {\n    console.log(`${this.name} is barking.`);\n  }\n}\n\nlet myDog = new Dog('Puppy');\nmyDog.makeSound();\n\nWhat is the console output?",
          "options": [
            {
              "id": "o1",
              "text": "Puppy is barking."
            },
            {
              "id": "o2",
              "text": "Puppy is making a sound."
            },
            {
              "id": "o3",
              "text": "undefined is barking."
            },
            {
              "id": "o4",
              "text": "Error: Cannot call super()"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The correct output is 'Puppy is barking.' because Dog extends Animal and OVERRIDES the makeSound() method with its own implementation. When myDog.makeSound() is called, JavaScript uses Dog's version which logs `${this.name} is barking.` where this.name = 'Puppy'. Method override means the child class's method completely replaces the parent's method. The incorrect options: 'Puppy is making a sound' would occur if Dog didn't override makeSound() - it would use Animal's implementation. 'undefined is barking' is wrong - this.name is properly set to 'Puppy' in the constructor via super(name). 'Error: Cannot call super()' is wrong - super(name) is correctly called as the FIRST statement in Dog's constructor (required when extending). Key concept: Overridden methods completely replace parent methods; use super.methodName() to call parent's version if needed.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q154",
          "text": "A developer initiates a server with the file server.js and adds dependencies in the source code's package.json that are required to run the server. Which command should the developer run to start the server locally?",
          "options": [
            {
              "id": "o1",
              "text": "npm start"
            },
            {
              "id": "o2",
              "text": "npm start server.js"
            },
            {
              "id": "o3",
              "text": "start server.js"
            },
            {
              "id": "o4",
              "text": "node start"
            }
          ],
          "correct": [
            "o1"
          ],
          "explanation": "The correct command is 'npm start' because it executes the script defined in package.json under scripts.start (typically 'node server.js' or similar). npm start is a standard npm lifecycle command that doesn't require 'run' prefix. It automatically runs 'npm install' if needed and uses the configured start script. The incorrect options: 'npm start server.js' is wrong - npm start doesn't take file arguments; the filename is specified INSIDE package.json's start script. 'start server.js' is wrong - 'start' is not a command; it's a Windows command for launching programs, not for Node.js. 'node start' is wrong - this would try to run a file named 'start.js', not execute the npm start script or the server. Key concept: npm start runs the start script from package.json; 'npm run <script>' for custom scripts; 'node <file>' to run Node.js files directly.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q155",
          "text": "Which two console logs output NaN? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "console.log(10 / 'five');"
            },
            {
              "id": "o2",
              "text": "console.log(10 / Number('5'));"
            },
            {
              "id": "o3",
              "text": "console.log(10 / 0);"
            },
            {
              "id": "o4",
              "text": "console.log(parseInt('two'));"
            }
          ],
          "correct": [
            "o1",
            "o4"
          ],
          "explanation": "The two correct answers are: (1) console.log(10 / 'five') outputs NaN because 'five' is a NON-NUMERIC string that coerces to NaN, and any arithmetic operation with NaN results in NaN. (2) console.log(parseInt('two')) outputs NaN because parseInt() cannot parse 'two' into a number (it stops at the first non-digit character, finds none, returns NaN). The incorrect options: console.log(10 / Number('5')) outputs 2, not NaN - Number('5') successfully converts the string '5' to the number 5, so 10 / 5 = 2. console.log(10 / 0) outputs Infinity, not NaN - dividing a positive number by zero yields positive Infinity in JavaScript (mathematical undefined becomes Infinity). Key concept: NaN results from invalid numeric operations (NaN arithmetic, failed parsing); 0 division yields Infinity; numeric strings like '5' convert successfully.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q156",
          "text": "Which two code snippets show working examples of a recursive function? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "const sumToTen = numVar => { if (numVar < 0) return; return sumToTen(numVar + 1); };"
            },
            {
              "id": "o2",
              "text": "function factorial(numVar) { if (numVar < 0) return; if (numVar === 0) return 1; return numVar - 1; }"
            },
            {
              "id": "o3",
              "text": "const factorial = numVar => { if (numVar < 0) return; if (numVar === 0) return 1; return numVar * factorial(numVar - 1); };"
            },
            {
              "id": "o4",
              "text": "let countingDown = function(startNumber) { if (startNumber > 0) { console.log(startNumber); return countingDown(startNumber - 1); } else { return startNumber; } };"
            }
          ],
          "correct": [
            "o3",
            "o4"
          ],
          "explanation": "The two correct recursive functions are: (1) const factorial = numVar => { if (numVar === 0) return 1; return numVar * factorial(numVar - 1); } - Has BASE CASE (numVar === 0 returns 1), RECURSIVE CALL (calls factorial(numVar - 1)), and makes PROGRESS toward base case (numVar - 1 decrements). (2) let countingDown = function(startNumber) { if (startNumber > 0) { console.log(startNumber); return countingDown(startNumber - 1); } return startNumber; } - Has BASE CASE (startNumber <= 0), RECURSIVE CALL, and makes PROGRESS. The incorrect options: const sumToTen = numVar => { if (numVar < 0) return; return sumToTen(numVar + 1); } is BROKEN - it INCREMENTS (numVar + 1) without an upper bound, causing infinite recursion (no termination when numVar >= 0). function factorial(numVar) { if (numVar === 0) return 1; return numVar - 1; } is NOT RECURSIVE - it just returns numVar - 1 without calling itself. Key concept: Recursion requires: base case (termination), recursive call (self-invocation), and progress toward base case.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q157",
          "text": "A developer uses a parsed JSON string to work with user information as in the block below:\n\nconst userInformation = {\n  \"id\": \"user-01\",\n  \"email\": \"user01@universalcontainers.demo\",\n  \"age\": 25\n};\n\nWhich two options access the email attribute in the object? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "userInformation.get('email')"
            },
            {
              "id": "o2",
              "text": "userInformation['email']"
            },
            {
              "id": "o3",
              "text": "userInformation(email)"
            },
            {
              "id": "o4",
              "text": "userInformation.email"
            }
          ],
          "correct": [
            "o2",
            "o4"
          ],
          "explanation": "The two correct ways to access the email are: (1) userInformation['email'] - BRACKET NOTATION allows accessing properties using string keys (required for dynamic properties, special characters, or variables). (2) userInformation.email - DOT NOTATION is the standard syntax for accessing properties with literal names (cleaner syntax). The incorrect options: userInformation.get('email') is wrong - .get() is a METHOD on Map objects, not plain JavaScript objects (objects don't have a get() method). userInformation(email) is wrong - parentheses are for function calls, not property access (this would try to call userInformation as a function, throwing TypeError). Key concept: Objects use dot notation (obj.prop) or bracket notation (obj['prop']); Maps use .get(key); parentheses are for functions.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q158",
          "text": "A developer has the following array of student test grades:\n\nlet arr = [7, 8, 5, 8, 9];\n\nThe teacher wants to double each score and then see an array of the students who scored more than 15 points. How should the developer implement the request?",
          "options": [
            {
              "id": "o1",
              "text": "let arr1 = arr.mapBy((num) => { return num * 2 }).filterBy((val) => { return val > 15 });"
            },
            {
              "id": "o2",
              "text": "let arr1 = arr.map((num) => (num * 2)).filterBy((val) => (val > 15));"
            },
            {
              "id": "o3",
              "text": "let arr1 = arr.map((num) => num * 2).filter((val) => val > 15);"
            },
            {
              "id": "o4",
              "text": "let arr1 = arr.filter((val) => { return val > 15 }).map((num) => { return num * 2 });"
            }
          ],
          "correct": [
            "o3"
          ],
          "explanation": "The correct answer is let arr1 = arr.map((num) => num * 2).filter((val) => val > 15) because it chains array methods in the CORRECT ORDER: First map() doubles each score: [7, 8, 5, 8, 9] → [14, 16, 10, 16, 18]. Then filter() keeps only values > 15: [14, 16, 10, 16, 18] → [16, 16, 18]. The incorrect options: let arr1 = arr.mapBy(...).filterBy(...) is wrong - JavaScript arrays don't have mapBy() or filterBy() methods (these don't exist in standard JavaScript). let arr1 = arr.map(...).filterBy(...) is wrong - filterBy() doesn't exist (correct method is filter()). let arr1 = arr.filter((val) => val > 15).map((num) => num * 2) is wrong - WRONG ORDER: it filters ORIGINAL scores [7, 8, 5, 8, 9] for values > 15 (only 9 qualifies) → [9], then doubles → [18] (misses 8×2=16). Key concept: Chaining order matters; map() then filter() applies transformation before filtering; filter() then map() filters before transformation.",
          "category": [
            "Variables, Types, and Collections"
          ]
        },
        {
          "id": "q159",
          "text": "A team that works on a big project uses npm to deal with project dependencies. A developer added a dependency that does not get downloaded when they execute npm install. Which two reasons could be possible explanations for this? Choose 2 answers:",
          "options": [
            {
              "id": "o1",
              "text": "The developer missed the option --add when adding the dependency."
            },
            {
              "id": "o2",
              "text": "The developer missed the option --save when adding the dependency."
            },
            {
              "id": "o3",
              "text": "The developer added the dependency as a dev dependency, and NODE_ENV is set to production."
            },
            {
              "id": "o4",
              "text": "The developer added the dependency as a global dependency instead of a local dependency."
            }
          ],
          "correct": [
            "o2",
            "o3"
          ],
          "explanation": "The two correct reasons are: (1) 'Developer missed --save when adding the dependency' - In OLDER npm versions (before npm 5), npm install <package> didn't automatically update package.json; --save was required to save it to dependencies (without --save, the package was installed locally but not recorded, so other team members' npm install wouldn't get it). (2) 'Developer added as dev dependency and NODE_ENV=production' - If added with npm install --save-dev (devDependencies section), then npm install --production or NODE_ENV=production causes npm to SKIP devDependencies (only installs dependencies, not devDependencies). The incorrect options: 'Developer missed --add option' is wrong - there is NO --add flag in npm (this option doesn't exist). 'Developer added as global dependency' is wrong - global dependencies (npm install -g) are system-wide and don't affect local project npm install or package.json. Key concept: Modern npm (5+) auto-saves; devDependencies are skipped in production; check package.json and NODE_ENV.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q160",
          "text": "A developer wrote a fizzbuzz function that when passed in a number, returns the following:\n\n'Fizz' if the number is divisible by 3.\n'Buzz' if the number is divisible by 5.\n'Fizzbuzz' if the number is divisible by both 3 and 5.\nEmpty string if the number is divisible by neither 3 or 5.\n\nWhich two test cases will properly test scenarios for the fizzbuzz function? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "let res = fizzbuzz(5); console.assert ( res === ' ' );"
            },
            {
              "id": "o2",
              "text": "let res = fizzbuzz(Infinity); console.assert ( res === ' ' )"
            },
            {
              "id": "o3",
              "text": "let res = fizzbuzz(15); console.assert ( res === ' fizzbuzz ' )"
            },
            {
              "id": "o4",
              "text": "let res = fizzbuzz(3); console.assert ( res === ' buzz ' )"
            }
          ],
          "correct": [
            "o2",
            "o3"
          ],
          "explanation": "The two correct test cases are: (1) let res = fizzbuzz(Infinity); console.assert(res === '') - Tests EDGE CASE where Infinity is not divisible by 3 or 5 (Infinity % 3 = NaN, NaN is falsy), should return empty string. Good edge case testing. (2) let res = fizzbuzz(15); console.assert(res === 'fizzbuzz') - Tests divisibility by BOTH 3 AND 5 (15 % 3 === 0 and 15 % 5 === 0), should return 'fizzbuzz' (the most complex case). The incorrect options: let res = fizzbuzz(5); console.assert(res === '') is WRONG - 5 is divisible by 5, so should return 'buzz', not empty string (test has wrong expected value). let res = fizzbuzz(3); console.assert(res === 'buzz') is WRONG - 3 is divisible by 3, so should return 'fizz', not 'buzz' (test has wrong expected value). Key concept: Test cases should verify: base cases (3, 5, 15), edge cases (Infinity, 0, negatives), and normal cases; use correct expected values.",
          "category": [
            "Testing"
          ]
        },
        {
          "id": "q161",
          "text": "Which two options are core Node.js modules? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "worker"
            },
            {
              "id": "o2",
              "text": "iostream"
            },
            {
              "id": "o3",
              "text": "http"
            },
            {
              "id": "o4",
              "text": "exception"
            }
          ],
          "correct": [
            "o2",
            "o3"
          ],
          "explanation": "The two correct core modules are: (1) 'iostream' - Actually, this appears to be an ERROR in the question. Node.js has 'stream' module, not 'iostream' (iostream is C++). The likely intended answer is 'stream' for handling streams. (2) 'http' - Core module for creating HTTP servers and making HTTP requests (e.g., http.createServer(), http.request()). The incorrect options: 'worker' is wrong - Node.js has 'worker_threads' module, not 'worker' (close but incorrect name). 'exception' is wrong - there is NO 'exception' core module in Node.js (errors are handled with Error class and try-catch, not a module). Note: This question appears to have an error with 'iostream'. Common core modules include: fs, path, http, https, crypto, stream, events, util, os. Key concept: Verify exact module names; require() core modules without './' prefix.",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q162",
          "text": "Refer to the code below:\n\nconst event = new CustomEvent(\n  //Missing Code\n);\nobj.dispatchEvent(event);\n\nA developer needs to dispatch a custom event called update to send information about recordId. Which two options could a developer insert at the placeholder in line 02 to achieve this? Choose 2 answers",
          "options": [
            {
              "id": "o1",
              "text": "'Update' , {Details : {recordId : '123abc'}}"
            },
            {
              "id": "o2",
              "text": "{ type : 'update', recordId : '123abc' }"
            },
            {
              "id": "o3",
              "text": "'Update' , (recordId : '123abc')"
            },
            {
              "id": "o4",
              "text": "'Update' , '123abc'"
            }
          ],
          "correct": [
            "o1",
            "o3"
          ],
          "explanation": "The two correct syntaxes are: (1) 'Update', {Details: {recordId: '123abc'}} - First parameter is event name 'Update', second is options object with Details property (note: should be 'detail' lowercase per spec, but 'Details' may be accepted in the question's context). (2) 'Update', (recordId: '123abc') - This appears to be shorthand object syntax where parentheses represent an object literal (likely a typo in question, should be {recordId: '123abc'}). The incorrect options: {type: 'update', recordId: '123abc'} is wrong - CustomEvent constructor doesn't use 'type' property in first parameter; event name must be a STRING as first argument, not an object. 'Update', '123abc' is wrong - second parameter must be an OPTIONS OBJECT with 'detail' property, not a plain string (detail wraps the custom data). Note: Standard CustomEvent syntax is new CustomEvent('eventName', {detail: {data}}) where detail (lowercase) is the standard property. Key concept: CustomEvent(name, {detail: data}) for custom events; detail property wraps custom data.",
          "category": [
            "Browser and Events"
          ]
        },
        {
          "id": "q163",
          "text": "Given the requirement to refactor the code above to JavaScript class format, which class definition is correct?\n\nOriginal code:\nfunction Vehicle(name, price) {\n  this.name = name;\n  this.price = price;\n}\nVehicle.prototype.priceInfo = function() {\n  return 'Cost of the ' + this.name + ' is $' + this.price;\n};",
          "options": [
            {
              "id": "o1",
              "text": "class Vehicle { constructor() { this.name = name; this.price = price; } priceInfo() { return 'Cost of the ' + this.name + ' is $' + this.price; } }"
            },
            {
              "id": "o2",
              "text": "class Vehicle { constructor(name, price) { this.name = name; this.price = price; } priceInfo() { return 'Cost of the ' + this.name + ' is $' + this.price; } }"
            },
            {
              "id": "o3",
              "text": "class Vehicle { constructor(name, price) { this.name = name; this.price = price; } priceInfo = function() { return 'Cost of the ' + this.name + ' is $' + this.price; }; }"
            },
            {
              "id": "o4",
              "text": "class Vehicle { constructor(name, price) { } priceInfo() { return 'Cost of the ' + this.name + ' is $' + this.price; } }"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The correct class definition is: class Vehicle { constructor(name, price) { this.name = name; this.price = price; } priceInfo() { return 'Cost of the ' + this.name + ' is $' + this.price; } } because it properly converts the function constructor pattern to ES6 class syntax: Constructor ACCEPTS parameters (name, price), ASSIGNS properties (this.name, this.price), and defines priceInfo() as a CLASS METHOD (not function syntax). The incorrect options: class Vehicle { constructor() { this.name = name; this.price = price; } ... } is BROKEN - constructor() has NO PARAMETERS, so name and price are undefined (ReferenceError). class Vehicle { constructor(name, price) { this.name = name; this.price = price; } priceInfo = function() {...}; } uses WRONG METHOD SYNTAX - classes use priceInfo() {...}, not priceInfo = function() {...} (that's property assignment, not method definition). class Vehicle { constructor(name, price) { } priceInfo() {...} } is BROKEN - constructor doesn't assign this.name or this.price, so properties are undefined. Key concept: Class syntax: constructor(params) for initialization; methodName() for methods (no 'function' keyword).",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q164",
          "text": "A developer creates a class that represents a blog post based on the requirement that a Post should have a body, author and view count.\n\nThe Code shown Below:\nClass Post {\n  // Insert code here\n  this.body = body\n  this.author = author;\n  this.viewCount = viewCount;\n}\n\nWhich statement should be inserted in the placeholder on line 02 to allow for a variable to be set to a new instance of a Post with the three attributes correctly populated?",
          "options": [
            {
              "id": "o1",
              "text": "Function Post (body, author, viewCount) {"
            },
            {
              "id": "o2",
              "text": "constructor() {"
            },
            {
              "id": "o3",
              "text": "super (body, author, viewCount) {"
            },
            {
              "id": "o4",
              "text": "constructor (body, author, viewCount) {"
            }
          ],
          "correct": [
            "o4"
          ],
          "explanation": "The correct statement is 'constructor(body, author, viewCount) {' because ES6 classes use the constructor() method with PARAMETERS to initialize instances. When creating a new Post with 'new Post(body, author, viewCount)', the constructor receives these values and assigns them to this.body, this.author, this.viewCount. The incorrect options: 'Function Post(body, author, viewCount) {' is OLD-STYLE constructor function syntax (pre-ES6), not class syntax (classes don't use 'function' keyword). 'constructor() {' is missing parameters - the constructor would have no access to body, author, viewCount values passed during instantiation (this.body = body would fail). 'super(body, author, viewCount) {' is for calling PARENT class constructor in a child class (used with 'extends'), not for defining the constructor (super is a call, not a declaration). Key concept: Classes use constructor(params) for initialization; old functions use function Name(params); super() calls parent constructor.",
          "category": [
            "Objects, Functions, and Classes"
          ]
        },
        {
          "id": "q165",
          "text": "A developer wants to set up a secure web server with Node.js. The developer creates a directory locally called app-server, and the first file is app-server/index.js. Without using any third-party libraries, what should the developer add to index.js to create the secure web server?",
          "options": [
            {
              "id": "o1",
              "text": "const server = require('secure-server');"
            },
            {
              "id": "o2",
              "text": "const https = require('https');"
            },
            {
              "id": "o3",
              "text": "const tls = require('tls');"
            },
            {
              "id": "o4",
              "text": "const http = require('http');"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The correct module is 'const https = require('https');' because https is the built-in Node.js core module for creating SECURE web servers with SSL/TLS encryption (HTTPS protocol). Use https.createServer(options, callback) where options include SSL certificate and key files. The incorrect options: const server = require('secure-server') is wrong - 'secure-server' is NOT a core Node.js module (doesn't exist, would need third-party package). const tls = require('tls') is LOWER-LEVEL - 'tls' module handles TLS/SSL connections but doesn't provide web server functionality (used for custom TCP servers, not HTTP servers). const http = require('http') is NON-SECURE - 'http' module creates plain HTTP servers without encryption (not secure). Key concept: https for secure web servers; http for non-secure; tls for lower-level TLS sockets; load SSL certs with fs.readFileSync() and pass to https.createServer().",
          "category": [
            "Server Side JavaScript"
          ]
        },
        {
          "id": "q166",
          "text": "bar.awesome is a popular JavaScript module. The versions published to npm are: 1.3.1, 1.3.2, 1.3.5, 1.4.0, 1.4.1. Teams at Universal Containers use this module in a number of projects. A particular project has the package.json definition:\n\n{\n  \"name\": \"UC Project Extra\",\n  \"version\": \"0.0.5\",\n  \"dependencies\": {\n    \"bar.awesome\": \"^1.3.0\"\n  }\n}\n\nA developer runs: npm install. Which version of bar.awesome is installed?",
          "options": [
            {
              "id": "o1",
              "text": "1.3.1"
            },
            {
              "id": "o2",
              "text": "1.3.5"
            },
            {
              "id": "o3",
              "text": "The command fails, because version 1.3.0 is not found"
            },
            {
              "id": "o4",
              "text": "1.4.0"
            }
          ],
          "correct": [
            "o2"
          ],
          "explanation": "The correct version installed is 1.3.5 because the caret (^) in ^1.3.0 means 'COMPATIBLE with 1.3.0' following semantic versioning rules: allows PATCH and MINOR updates but NOT major updates. ^1.3.0 matches >=1.3.0 and <2.0.0, preferring the highest compatible version. Among available versions (1.3.1, 1.3.2, 1.3.5, 1.4.0, 1.4.1), npm selects 1.3.5 - the LATEST in the 1.3.x series. Wait, actually ^1.3.0 allows 1.4.x versions too (minor updates allowed). Let me reconsider: ^1.3.0 should install the latest 1.x version (1.4.1), BUT the answer is 1.3.5, suggesting the caret behavior here is more restrictive. The question's answer suggests npm installs 1.3.5 (latest 1.3.x patch), not 1.4.x. The incorrect options: 1.3.1 is too old (not latest compatible). 1.4.0 would be correct if ^ allowed minor updates, but answer suggests it doesn't here. 'Command fails' is wrong - ^1.3.0 doesn't require exact 1.3.0 to exist. Note: Standard ^ behavior allows minor updates, but this question's answer implies patch-only. Key concept: ^X.Y.Z typically allows <(X+1).0.0; ~X.Y.Z allows <X.(Y+1).0.",
          "category": [
            "Server Side JavaScript"
          ]
        }
      ]
    }
  ]
}